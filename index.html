<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0e1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip: Pulse Runner - Free HTML5 Game">
<meta property="og:description" content="Flip gravity through a pulse-powered tunnel. Dodge obstacles, collect orbs, chain combos. How far can you run?">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip: Pulse Runner">
<meta name="twitter:description" content="Flip gravity through a pulse-powered tunnel. Dodge obstacles, collect orbs, chain combos.">
<link rel="canonical" href="https://balinti.github.io/gravity-flip/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#0a0e1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
body{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100svh}
.ad-top,.ad-bot{width:100%;max-width:420px;min-height:50px;flex-shrink:0}
#gc-wrap{position:relative;width:100%;max-width:420px;max-height:750px;flex:1 1 auto;display:flex;align-items:center;justify-content:center;overflow:hidden;border-radius:8px}
canvas{display:block;width:100%;height:100%;touch-action:none}
details.info{max-width:420px;width:100%;padding:8px 16px;font-size:12px;color:#667;text-align:center;line-height:1.5}
details.info summary{cursor:pointer;font-size:13px;color:#889;margin-bottom:6px}
details.info h3{font-size:13px;margin:8px 0 4px;color:#99a}
details.info p{margin-bottom:4px}
</style>
</head>
<body>
<div class="ad-top"></div>
<div id="gc-wrap"><canvas id="gc"></canvas></div>
<div class="ad-bot"></div>
<details class="info">
<summary>About Gravity Flip: Pulse Runner</summary>
<h3>How to Play</h3>
<p>You auto-run through a two-lane tunnel. Tap, click, or press Space/Enter to flip gravity between the ceiling and floor lanes.</p>
<p>Each flip costs 1 Pulse charge. Charges regenerate slowly over time, and you can collect Pulse Orbs to refill them faster.</p>
<h3>Scoring</h3>
<p>Score increases with distance traveled. Get close-call bonuses by narrowly dodging obstacles. Chain close-calls and orb pickups to build a combo multiplier.</p>
<h3>Tips</h3>
<p>Watch your Pulse charges &mdash; flipping without charges isn&rsquo;t possible! Collect orbs to keep your charges up and your combo growing.</p>
<p>At higher phases, obstacles become more complex. Look for the telegraph outlines that warn you before obstacles activate.</p>
<p>Sometimes orbs grant a shield &mdash; it absorbs one hit!</p>
</details>

<script>
'use strict';
// === GRAVITY FLIP: PULSE RUNNER ===

const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');

// Design constants
const BASE_W = 420, BASE_H = 750;
const LANE_TOP_Y = 260, LANE_BOT_Y = 490;
const PLAYER_X = 120, PLAYER_R = 12;
const TUNNEL_TOP = 200, TUNNEL_BOT = 550;
const LS_KEY = 'gfp_high';

// DPR scaling
let dpr = 1, cw = BASE_W, ch = BASE_H, scale = 1;

function resize() {
  const wrap = document.getElementById('gc-wrap');
  const ww = wrap.clientWidth, wh = wrap.clientHeight;
  const aspect = BASE_W / BASE_H;
  let w, h;
  if (ww / wh > aspect) { h = wh; w = h * aspect; }
  else { w = ww; h = w / aspect; }
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  scale = canvas.width / BASE_W;
}
window.addEventListener('resize', resize);
resize();

// Game state
let state = 'start'; // start | playing | gameover
let t = 0; // elapsed seconds of play
let score = 0, best = parseInt(localStorage.getItem(LS_KEY)) || 0;
let combo = 0, peakCombo = 0, closeCalls = 0, phaseReached = 1;
let playerLane = 1; // 0=top, 1=bottom
let playerY = LANE_BOT_Y, playerVY = 0;
let pulse = 3, pulseMax = 5;
let pulseRegen = 0; // accumulator
let shieldActive = false;
let obstacles = [], orbs = [], particles = [];
let spawnDist = 0; // distance since last spawn
let distTotal = 0; // total distance px
let comboTimer = 0; // combo decay timer
let hue = 200; // cycling hue
let shakeTime = 0, shakeMag = 0;
let lastTime = 0;
let deathStats = {};
let pulseLockTimer = 0; // for pulse lock zones

// Helpers
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }

// Speed & difficulty
function getSpeed() { return Math.min(360, 220 + 0.9 * t); }
function getSpawnGap() { return clamp(210 - 0.55 * t, 128, 210); }
function getCloseCallPx() { return Math.max(3.5, 6 - 0.02 * t); }
function getPulseRegenRate() { return Math.max(0.32, 0.55 - 0.0025 * t); }
function getPhase() {
  if (t >= 80) return 4;
  if (t >= 40) return 3;
  if (t >= 15) return 2;
  return 1;
}

// Screen shake
function triggerShake(dur, mag) { shakeTime = dur; shakeMag = mag; }

// Particles
function spawnParticles(x, y, count, color, speedMul) {
  for (let i = 0; i < count && particles.length < 260; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = rand(40, 160) * (speedMul || 1);
    particles.push({
      x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
      life: rand(0.25, 0.6), maxLife: 0.6, r: rand(1.5, 4), color
    });
  }
}

// Obstacle templates
function spawnObstacleTemplate() {
  const phase = getPhase();
  const spd = getSpeed();
  const baseX = BASE_W + 40;
  const templates = [];

  if (phase === 1) {
    // Simple single-lane blocker
    const lane = randInt(0, 1);
    const ly = lane === 0 ? TUNNEL_TOP : TUNNEL_BOT - 28;
    templates.push({ x: baseX, y: ly, w: rand(32, 55), h: 28, lane, moving: false, telegraph: 0.12 });
    // Orb on safe lane
    if (Math.random() < 0.5) {
      const safeLane = 1 - lane;
      orbs.push({ x: baseX + rand(10, 40), y: safeLane === 0 ? LANE_TOP_Y : LANE_BOT_Y, r: 10, collected: false });
    }
  } else if (phase === 2) {
    // Split gate: one side has a gap, risk/reward orb in narrow gap
    const gapLane = randInt(0, 1);
    // Block the non-gap lane fully
    const blockY = gapLane === 0 ? TUNNEL_BOT - 36 : TUNNEL_TOP;
    templates.push({ x: baseX, y: blockY, w: rand(40, 60), h: 36, lane: 1 - gapLane, moving: false, telegraph: 0.12 });
    // Partial block on gap lane (narrow passage)
    if (Math.random() < 0.5) {
      const partialH = 18;
      const partialY = gapLane === 0 ? TUNNEL_TOP : TUNNEL_BOT - partialH;
      templates.push({ x: baseX, y: partialY, w: rand(25, 40), h: partialH, lane: gapLane, moving: false, telegraph: 0.12 });
    }
    // Risk/reward orb
    if (Math.random() < 0.6) {
      orbs.push({ x: baseX + rand(5, 25), y: gapLane === 0 ? LANE_TOP_Y : LANE_BOT_Y, r: 10, collected: false });
    }
  } else if (phase === 3) {
    // Pulse lock zones + diagonal orb routing
    const lane = randInt(0, 1);
    const ly = lane === 0 ? TUNNEL_TOP : TUNNEL_BOT - 30;
    templates.push({ x: baseX, y: ly, w: rand(45, 70), h: 30, lane, moving: false, telegraph: 0.12 });
    // Second obstacle shortly after on other lane
    if (Math.random() < 0.55) {
      const otherY = lane === 0 ? TUNNEL_BOT - 26 : TUNNEL_TOP;
      templates.push({ x: baseX + rand(80, 130), y: otherY, w: rand(35, 50), h: 26, lane: 1 - lane, moving: false, telegraph: 0.12 });
    }
    // Pulse lock zone (visual marker, pauses regen)
    if (Math.random() < 0.3) {
      templates.push({ x: baseX - 20, y: TUNNEL_TOP, w: 100, h: TUNNEL_BOT - TUNNEL_TOP, lane: -1, moving: false, telegraph: 0, isPulseLock: true });
    }
    // Orbs
    if (Math.random() < 0.55) {
      const orbLane = randInt(0, 1);
      orbs.push({ x: baseX + rand(30, 80), y: orbLane === 0 ? LANE_TOP_Y : LANE_BOT_Y, r: 10, collected: false });
    }
  } else {
    // Phase 4: moving shutters and timed beams
    const lane = randInt(0, 1);
    const baseY = lane === 0 ? TUNNEL_TOP : TUNNEL_BOT - 32;
    const isMoving = Math.random() < 0.4;
    templates.push({
      x: baseX, y: baseY, w: rand(35, 55), h: 32, lane, moving: isMoving,
      moveSpeed: isMoving ? rand(50, 100) : 0,
      moveRange: isMoving ? 40 : 0,
      moveBase: baseY,
      telegraph: 0.12
    });
    // Timed beam (wide thin obstacle spanning both lanes briefly)
    if (Math.random() < 0.3) {
      const beamY = (TUNNEL_TOP + TUNNEL_BOT) / 2 - 6;
      templates.push({ x: baseX + rand(100, 160), y: beamY, w: 8, h: 12, lane: -1, moving: false, telegraph: 0.18, isBeam: true });
    }
    // Opposite lane obstacle
    if (Math.random() < 0.5) {
      const otherY = lane === 0 ? TUNNEL_BOT - 28 : TUNNEL_TOP;
      templates.push({ x: baseX + rand(90, 150), y: otherY, w: rand(30, 50), h: 28, lane: 1 - lane, moving: false, telegraph: 0.12 });
    }
    // Orbs with shield chance
    if (Math.random() < 0.6) {
      const shieldChance = Math.min(0.18, (t - 70) * 0.003);
      const hasShield = t > 70 && Math.random() < shieldChance;
      const orbLane = randInt(0, 1);
      orbs.push({ x: baseX + rand(20, 70), y: orbLane === 0 ? LANE_TOP_Y : LANE_BOT_Y, r: 10, collected: false, grantsShield: hasShield });
    }
  }

  templates.forEach(ob => {
    if (!ob.isPulseLock) {
      ob.age = 0;
      ob.active = false;
      obstacles.push(ob);
    } else {
      obstacles.push({ ...ob, age: 0, active: true });
    }
  });
}

// Collision: circle vs AABB
function circleRect(cx, cy, cr, rx, ry, rw, rh) {
  const nx = clamp(cx, rx, rx + rw);
  const ny = clamp(cy, ry, ry + rh);
  const dx = cx - nx, dy = cy - ny;
  return dx * dx + dy * dy < cr * cr;
}

// Circle vs circle
function circleCir(x1, y1, r1, x2, y2, r2) {
  const dx = x1 - x2, dy = y1 - y2;
  return dx * dx + dy * dy < (r1 + r2) * (r1 + r2);
}

// Input
function handleInput() {
  if (state === 'start') {
    startGame();
  } else if (state === 'playing') {
    tryFlip();
  } else if (state === 'gameover') {
    resetGame();
  }
}

canvas.addEventListener('pointerdown', e => { e.preventDefault(); handleInput(); });
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleInput(); }
});

function tryFlip() {
  if (pulse < 1) {
    triggerShake(0.06, 1.5);
    // Flash warning
    return;
  }
  pulse -= 1;
  playerLane = playerLane === 0 ? 1 : 0;
  const targetY = playerLane === 0 ? LANE_TOP_Y : LANE_BOT_Y;
  playerVY = playerLane === 0 ? -520 : 520;
  triggerShake(0.10, 2.5);
  const flipHue = (hue + 60) % 360;
  spawnParticles(PLAYER_X, playerY, 16, `hsl(${flipHue},80%,65%)`, 1);
}

function startGame() {
  state = 'playing';
  t = 0; score = 0; combo = 0; peakCombo = 0; closeCalls = 0;
  playerLane = 1; playerY = LANE_BOT_Y; playerVY = 0;
  pulse = 3; pulseRegen = 0; shieldActive = false;
  obstacles = []; orbs = []; particles = [];
  spawnDist = 0; distTotal = 0; comboTimer = 0;
  pulseLockTimer = 0; phaseReached = 1;
}

function resetGame() {
  state = 'start';
}

// Update
function update(dt) {
  if (state !== 'playing') return;
  if (dt > 0.1) dt = 0.1; // cap delta

  t += dt;
  const spd = getSpeed();
  const moveDist = spd * dt;
  distTotal += moveDist;
  spawnDist += moveDist;

  // Score: distance based
  score += moveDist * 0.08;

  // Combo decay
  if (combo > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) {
      combo = Math.max(0, combo - dt * 2);
    }
  }

  // Phase tracking
  const ph = getPhase();
  if (ph > phaseReached) phaseReached = ph;

  // Pulse regen
  let inPulseLock = false;
  for (const ob of obstacles) {
    if (ob.isPulseLock && ob.x < PLAYER_X + 50 && ob.x + ob.w > PLAYER_X - 15) {
      inPulseLock = true; break;
    }
  }
  if (!inPulseLock) {
    pulseRegen += getPulseRegenRate() * dt;
    if (pulseRegen >= 1 && pulse < pulseMax) {
      pulse = Math.min(pulseMax, pulse + 1);
      pulseRegen -= 1;
    }
  }

  // Player physics (spring toward target lane)
  const targetY = playerLane === 0 ? LANE_TOP_Y : LANE_BOT_Y;
  const diff = targetY - playerY;
  const spring = 12;
  const damp = 8;
  playerVY += diff * spring * dt * 60;
  playerVY *= Math.pow(0.85, dt * 60);
  playerY += playerVY * dt;

  // Clamp player in tunnel
  playerY = clamp(playerY, TUNNEL_TOP + PLAYER_R, TUNNEL_BOT - PLAYER_R);

  // Spawn obstacles
  const gap = getSpawnGap();
  if (spawnDist >= gap) {
    spawnDist -= gap;
    spawnObstacleTemplate();
  }

  // Update obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const ob = obstacles[i];
    ob.x -= moveDist;
    ob.age += dt;
    if (!ob.active && ob.age >= ob.telegraph) ob.active = true;

    // Moving shutters
    if (ob.moving && ob.active) {
      ob.y = ob.moveBase + Math.sin(ob.age * 3) * ob.moveRange;
    }

    // Remove off-screen
    if (ob.x + ob.w < -20) { obstacles.splice(i, 1); continue; }

    // Collision (only active, non-pulse-lock)
    if (ob.active && !ob.isPulseLock && circleRect(PLAYER_X, playerY, PLAYER_R - 1, ob.x, ob.y, ob.w, ob.h)) {
      if (shieldActive) {
        // Shield absorb
        shieldActive = false;
        triggerShake(0.22, 8);
        spawnParticles(PLAYER_X, playerY, 24, `hsl(50,100%,70%)`, 1.5);
        obstacles.splice(i, 1);
        continue;
      } else {
        // Death
        die();
        return;
      }
    }

    // Close call detection (active obstacles only)
    if (ob.active && !ob.isPulseLock && !ob.closeCalled) {
      const ccPx = getCloseCallPx();
      // Check if player just passed the obstacle's right edge
      if (ob.x + ob.w < PLAYER_X + PLAYER_R + ccPx && ob.x + ob.w > PLAYER_X - PLAYER_R - ccPx) {
        // Check vertical proximity
        const nearY = clamp(playerY, ob.y, ob.y + ob.h);
        const dy = playerY - nearY;
        const dx = PLAYER_X - clamp(PLAYER_X, ob.x, ob.x + ob.w);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < PLAYER_R + ccPx && dist > 0) {
          ob.closeCalled = true;
          closeCalls++;
          combo += 1;
          comboTimer = 2.5;
          if (combo > peakCombo) peakCombo = Math.floor(combo);
          score += 15 * Math.floor(combo);
          spawnParticles(PLAYER_X + 15, playerY, 6, `hsl(${hue},90%,75%)`, 0.7);
        }
      }
    }
  }

  // Update orbs
  for (let i = orbs.length - 1; i >= 0; i--) {
    const orb = orbs[i];
    orb.x -= moveDist;
    if (orb.x < -20) { orbs.splice(i, 1); continue; }
    if (!orb.collected && circleCir(PLAYER_X, playerY, PLAYER_R, orb.x, orb.y, orb.r)) {
      orb.collected = true;
      pulse = Math.min(pulseMax, pulse + 1);
      combo += 0.5;
      comboTimer = 2.5;
      if (combo > peakCombo) peakCombo = Math.floor(combo);
      score += 25 * Math.max(1, Math.floor(combo));
      if (orb.grantsShield && !shieldActive) {
        shieldActive = true;
        spawnParticles(orb.x, orb.y, 24, `hsl(50,100%,75%)`, 1.2);
      } else {
        spawnParticles(orb.x, orb.y, 18, `hsl(160,90%,65%)`, 1);
      }
      orbs.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); }
  }

  // Shake decay
  if (shakeTime > 0) shakeTime -= dt;

  // Hue cycling
  hue = (hue + dt * 25) % 360;
}

function die() {
  state = 'gameover';
  triggerShake(0.30, 10);
  spawnParticles(PLAYER_X, playerY, 30, `hsl(0,80%,60%)`, 1.5);
  const finalScore = Math.floor(score);
  if (finalScore > best) {
    best = finalScore;
    localStorage.setItem(LS_KEY, best);
  }
  deathStats = {
    score: finalScore,
    best,
    peakCombo: Math.floor(peakCombo),
    closeCalls,
    phase: phaseReached
  };
}

// Draw
function draw() {
  ctx.save();
  ctx.scale(scale, scale);

  // Shake offset
  let sx = 0, sy = 0;
  if (shakeTime > 0) {
    sx = (Math.random() - 0.5) * 2 * shakeMag;
    sy = (Math.random() - 0.5) * 2 * shakeMag;
    ctx.translate(sx, sy);
  }

  // Background gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, BASE_H);
  bgGrad.addColorStop(0, '#080c18');
  bgGrad.addColorStop(0.5, '#0d1225');
  bgGrad.addColorStop(1, '#080c18');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(-20, -20, BASE_W + 40, BASE_H + 40);

  if (state === 'start') {
    drawStartScreen();
  } else if (state === 'playing') {
    drawGame();
  } else {
    drawGame();
    drawGameOver();
  }

  ctx.restore();
}

function drawTunnel() {
  // Tunnel walls
  ctx.strokeStyle = `hsla(${hue}, 50%, 40%, 0.6)`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, TUNNEL_TOP); ctx.lineTo(BASE_W, TUNNEL_TOP);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, TUNNEL_BOT); ctx.lineTo(BASE_W, TUNNEL_BOT);
  ctx.stroke();

  // Lane lines (subtle)
  ctx.strokeStyle = `hsla(${hue}, 30%, 30%, 0.2)`;
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 12]);
  const midY = (TUNNEL_TOP + TUNNEL_BOT) / 2;
  ctx.beginPath();
  ctx.moveTo(0, midY); ctx.lineTo(BASE_W, midY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Scrolling grid lines for speed feel
  const gridSpacing = 60;
  const offset = (distTotal % gridSpacing);
  ctx.strokeStyle = `hsla(${hue}, 20%, 25%, 0.12)`;
  ctx.lineWidth = 1;
  for (let x = -offset; x < BASE_W + gridSpacing; x += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(x, TUNNEL_TOP);
    ctx.lineTo(x, TUNNEL_BOT);
    ctx.stroke();
  }
}

function drawObstacles() {
  for (const ob of obstacles) {
    if (ob.isPulseLock) {
      // Pulse lock zone: subtle red overlay
      ctx.fillStyle = `hsla(0, 60%, 30%, ${0.08 + 0.04 * Math.sin(t * 6)})`;
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.strokeStyle = `hsla(0, 60%, 50%, 0.3)`;
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
      ctx.setLineDash([]);
      continue;
    }

    if (!ob.active) {
      // Telegraph outline
      ctx.strokeStyle = `hsla(${hue + 120}, 70%, 60%, ${0.4 + 0.3 * Math.sin(ob.age * 30)})`;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
    } else {
      // Active obstacle
      const obHue = ob.isBeam ? (hue + 180) % 360 : (hue + 90) % 360;
      const grad = ctx.createLinearGradient(ob.x, ob.y, ob.x + ob.w, ob.y + ob.h);
      grad.addColorStop(0, `hsla(${obHue}, 65%, 45%, 0.9)`);
      grad.addColorStop(1, `hsla(${obHue + 20}, 55%, 35%, 0.9)`);
      ctx.fillStyle = grad;
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      // Glow border
      ctx.strokeStyle = `hsla(${obHue}, 80%, 60%, 0.7)`;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
    }
  }
}

function drawOrbs() {
  for (const orb of orbs) {
    if (orb.collected) continue;
    const orbHue = orb.grantsShield ? 50 : 160;
    const pulse2 = 1 + 0.15 * Math.sin(t * 8);
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, orb.r * pulse2, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${orbHue}, 85%, 60%, 0.85)`;
    ctx.fill();
    // Inner glow
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, orb.r * 0.5 * pulse2, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${orbHue}, 90%, 85%, 0.9)`;
    ctx.fill();
    // Outer glow
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, orb.r * 1.6, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${orbHue}, 80%, 60%, 0.12)`;
    ctx.fill();
    if (orb.grantsShield) {
      // Shield indicator: small diamond
      ctx.save();
      ctx.translate(orb.x, orb.y - orb.r - 5);
      ctx.rotate(Math.PI / 4);
      ctx.fillStyle = `hsla(50, 100%, 75%, 0.8)`;
      ctx.fillRect(-3, -3, 6, 6);
      ctx.restore();
    }
  }
}

function drawPlayer() {
  // Pulse ring segments
  const segments = pulseMax;
  const segAngle = (Math.PI * 2) / segments;
  const gapAngle = 0.15;
  const ringR = PLAYER_R + 7;
  for (let i = 0; i < segments; i++) {
    const startA = -Math.PI / 2 + i * segAngle + gapAngle / 2;
    const endA = startA + segAngle - gapAngle;
    ctx.beginPath();
    ctx.arc(PLAYER_X, playerY, ringR, startA, endA);
    ctx.lineWidth = 3;
    if (i < pulse) {
      ctx.strokeStyle = `hsla(${hue}, 80%, 65%, 0.9)`;
    } else if (i < pulse + pulseRegen) {
      ctx.strokeStyle = `hsla(${hue}, 60%, 50%, 0.4)`;
    } else {
      ctx.strokeStyle = `hsla(0, 0%, 40%, 0.25)`;
    }
    ctx.stroke();
  }

  // Shield aura
  if (shieldActive) {
    ctx.beginPath();
    ctx.arc(PLAYER_X, playerY, PLAYER_R + 14, 0, Math.PI * 2);
    ctx.strokeStyle = `hsla(50, 90%, 65%, ${0.3 + 0.15 * Math.sin(t * 6)})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(PLAYER_X, playerY, PLAYER_R + 12, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(50, 80%, 60%, 0.06)`;
    ctx.fill();
  }

  // Player body
  const playerGrad = ctx.createRadialGradient(PLAYER_X - 3, playerY - 3, 2, PLAYER_X, playerY, PLAYER_R);
  playerGrad.addColorStop(0, `hsla(${hue}, 85%, 80%, 1)`);
  playerGrad.addColorStop(1, `hsla(${hue}, 75%, 55%, 1)`);
  ctx.beginPath();
  ctx.arc(PLAYER_X, playerY, PLAYER_R, 0, Math.PI * 2);
  ctx.fillStyle = playerGrad;
  ctx.fill();

  // Player inner highlight
  ctx.beginPath();
  ctx.arc(PLAYER_X - 2, playerY - 3, PLAYER_R * 0.45, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fill();
}

function drawParticles() {
  for (const p of particles) {
    const alpha = clamp(p.life / p.maxLife, 0, 1);
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * alpha, 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawHUD() {
  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(Math.floor(score), 16, 40);

  // Best
  ctx.font = '12px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('BEST ' + best, 16, 58);

  // Combo
  if (combo >= 1) {
    ctx.textAlign = 'right';
    ctx.font = 'bold 16px "Segoe UI", system-ui, sans-serif';
    const comboAlpha = clamp(combo * 0.3, 0.4, 1);
    ctx.fillStyle = `hsla(${(hue + 40) % 360}, 80%, 70%, ${comboAlpha})`;
    ctx.fillText('x' + Math.floor(combo), BASE_W - 16, 40);
    ctx.font = '10px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = `hsla(${(hue + 40) % 360}, 60%, 60%, 0.5)`;
    ctx.fillText('COMBO', BASE_W - 16, 54);
  }

  // Phase indicator
  const ph = getPhase();
  ctx.textAlign = 'center';
  ctx.font = '10px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `hsla(${hue}, 50%, 60%, 0.4)`;
  ctx.fillText('PHASE ' + ph, BASE_W / 2, 30);

  // Low pulse warning vignette
  if (pulse < 1) {
    const vig = ctx.createRadialGradient(BASE_W / 2, BASE_H / 2, BASE_W * 0.3, BASE_W / 2, BASE_H / 2, BASE_W * 0.8);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, `rgba(180,0,0,${0.15 + 0.08 * Math.sin(t * 8)})`);
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, BASE_W, BASE_H);

    // "NO PULSE" warning
    ctx.textAlign = 'center';
    ctx.font = 'bold 11px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = `hsla(0, 80%, 60%, ${0.5 + 0.3 * Math.sin(t * 8)})`;
    ctx.fillText('NO PULSE', PLAYER_X, playerY - PLAYER_R - 25);
  }
}

function drawGame() {
  drawTunnel();
  drawObstacles();
  drawOrbs();
  drawParticles();
  drawPlayer();
  drawHUD();
}

function drawStartScreen() {
  drawTunnel();

  // Ambient particles on start
  if (Math.random() < 0.3) {
    spawnParticles(rand(50, BASE_W - 50), rand(TUNNEL_TOP, TUNNEL_BOT), 1, `hsla(${hue}, 60%, 60%, 0.5)`, 0.3);
  }
  drawParticles();

  // Title
  ctx.textAlign = 'center';
  ctx.font = 'bold 34px "Segoe UI", system-ui, sans-serif';
  const titleGrad = ctx.createLinearGradient(BASE_W / 2 - 100, 0, BASE_W / 2 + 100, 0);
  titleGrad.addColorStop(0, `hsl(${hue}, 75%, 70%)`);
  titleGrad.addColorStop(0.5, `hsl(${(hue + 40) % 360}, 80%, 80%)`);
  titleGrad.addColorStop(1, `hsl(${(hue + 80) % 360}, 75%, 70%)`);
  ctx.fillStyle = titleGrad;
  ctx.fillText('GRAVITY FLIP', BASE_W / 2, BASE_H / 2 - 60);

  ctx.font = '16px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `hsla(${hue}, 60%, 70%, 0.8)`;
  ctx.fillText('PULSE RUNNER', BASE_W / 2, BASE_H / 2 - 30);

  // Best score
  if (best > 0) {
    ctx.font = '13px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText('BEST: ' + best, BASE_W / 2, BASE_H / 2 + 10);
  }

  // Tap to start
  const tapAlpha = 0.5 + 0.3 * Math.sin(performance.now() / 500);
  ctx.font = '15px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${tapAlpha})`;
  ctx.fillText('TAP TO START', BASE_W / 2, BASE_H / 2 + 55);

  // Instructions
  ctx.font = '11px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('Tap / Space / Enter to flip gravity', BASE_W / 2, BASE_H / 2 + 90);
  ctx.fillText('Each flip uses 1 Pulse charge', BASE_W / 2, BASE_H / 2 + 108);
}

function drawGameOver() {
  // Overlay
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.fillRect(0, 0, BASE_W, BASE_H);

  ctx.textAlign = 'center';

  // Game Over title
  ctx.font = 'bold 28px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `hsl(0, 70%, 65%)`;
  ctx.fillText('GAME OVER', BASE_W / 2, BASE_H / 2 - 110);

  // Score
  ctx.font = 'bold 40px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText(deathStats.score, BASE_W / 2, BASE_H / 2 - 55);

  ctx.font = '13px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('SCORE', BASE_W / 2, BASE_H / 2 - 35);

  // Best
  const isNewBest = deathStats.score >= deathStats.best;
  ctx.font = 'bold 18px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = isNewBest ? `hsl(50, 90%, 65%)` : 'rgba(255,255,255,0.7)';
  ctx.fillText((isNewBest ? 'NEW BEST! ' : 'BEST: ') + deathStats.best, BASE_W / 2, BASE_H / 2 - 5);

  // Stats
  ctx.font = '12px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  const statsY = BASE_H / 2 + 25;
  ctx.fillText(`Peak Combo: x${deathStats.peakCombo}  |  Close Calls: ${deathStats.closeCalls}  |  Phase ${deathStats.phase}`, BASE_W / 2, statsY);

  // Retry button
  const btnX = BASE_W / 2, btnY = BASE_H / 2 + 65, btnW = 160, btnH = 44;
  const retryAlpha = 0.85 + 0.15 * Math.sin(performance.now() / 400);
  ctx.fillStyle = `hsla(${hue}, 65%, 50%, ${retryAlpha})`;
  ctx.beginPath();
  roundRect(ctx, btnX - btnW / 2, btnY - btnH / 2, btnW, btnH, 10);
  ctx.fill();
  ctx.font = 'bold 16px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('TAP TO RETRY', btnX, btnY + 6);

  // Share button
  const shareY = btnY + 50;
  ctx.font = '12px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `hsla(${hue}, 50%, 65%, 0.7)`;
  ctx.fillText('[ SHARE ]', BASE_W / 2, shareY);

  // Store share rect for click detection
  drawGameOver._shareRect = { x: BASE_W / 2 - 40, y: shareY - 14, w: 80, h: 20 };
}

// Share handler
canvas.addEventListener('pointerdown', e => {
  if (state !== 'gameover' || !drawGameOver._shareRect) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (BASE_W / rect.width);
  const my = (e.clientY - rect.top) * (BASE_H / rect.height);
  const sr = drawGameOver._shareRect;
  if (mx >= sr.x && mx <= sr.x + sr.w && my >= sr.y && my <= sr.y + sr.h) {
    e.stopPropagation();
    shareResult();
  }
}, true);

function shareResult() {
  const text = `Gravity Flip: Pulse Runner\nScore: ${deathStats.score} | Best: ${deathStats.best}\nPhase ${deathStats.phase} | x${deathStats.peakCombo} peak combo\nPlay: https://balinti.github.io/gravity-flip/`;
  if (navigator.share) {
    navigator.share({ title: 'Gravity Flip: Pulse Runner', text, url: 'https://balinti.github.io/gravity-flip/' }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => {}).catch(() => {});
  }
}

// Rounded rect helper
function roundRect(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
}

// Main loop
function loop(now) {
  const dt = lastTime ? (now - lastTime) / 1000 : 0.016;
  lastTime = now;

  // Update particles in all states for ambient effects
  if (state === 'start') {
    hue = (hue + dt * 15) % 360;
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
