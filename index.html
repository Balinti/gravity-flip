<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="theme-color" content="#0b0f1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity up/down while dodging obstacles. Collect stars for bonus points in this hyper-casual HTML5 game.">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300' viewBox='0 0 400 300'%3E%3Crect fill='%230b0f1a' width='400' height='300'/%3E%3Ctext x='200' y='130' text-anchor='middle' fill='%2300e5ff' font-size='36' font-family='Arial'%3EGravity Flip%3C/text%3E%3Ctext x='200' y='180' text-anchor='middle' fill='%23ff00aa' font-size='18' font-family='Arial'%3EHeatline%3C/text%3E%3Ccircle cx='200' cy='220' r='12' fill='%2300e5ff'/%3E%3C/svg%3E">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity up/down while dodging obstacles. Collect stars for bonus points in this hyper-casual HTML5 game.">
<meta name="twitter:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300' viewBox='0 0 400 300'%3E%3Crect fill='%230b0f1a' width='400' height='300'/%3E%3Ctext x='200' y='130' text-anchor='middle' fill='%2300e5ff' font-size='36' font-family='Arial'%3EGravity Flip%3C/text%3E%3Ctext x='200' y='180' text-anchor='middle' fill='%23ff00aa' font-size='18' font-family='Arial'%3EHeatline%3C/text%3E%3Ccircle cx='200' cy='220' r='12' fill='%2300e5ff'/%3E%3C/svg%3E">
<link rel="canonical" href="https://balinti.github.io/gravity-flip/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#060a12;font-family:'Segoe UI',Arial,sans-serif;display:grid;place-items:center}
#wrap{position:relative;width:min(420px,100vw);height:min(750px,100vh);aspect-ratio:420/750;display:flex;flex-direction:column;align-items:center}
canvas{display:block;width:100%;flex:1;border-radius:8px;touch-action:none}
#footer{width:100%;padding:6px 12px;text-align:center;font-size:11px;color:#445;line-height:1.6}
#footer a{color:#556;text-decoration:none;margin:0 6px}
#footer a:hover{color:#88a}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="footer">
<a href="#">How to Play</a> | <a href="#">Privacy</a> | <a href="#">Contact</a><br>
Gravity Flip &copy; 2026 &mdash; A free hyper-casual HTML5 game. Flip gravity to dodge hazards and thread heat gates.
</div>
</div>
<script>
'use strict';
(()=>{

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const DPR = Math.min(2, devicePixelRatio || 1);
const LS_KEY = 'gravityflip_highscore_v1';
const LS_MULT_KEY = 'gravityflip_bestmult_v1';

/* ========== Canvas sizing ========== */
let W, H;
function resize() {
  const rect = canvas.getBoundingClientRect();
  W = rect.width;
  H = rect.height;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resize();
window.addEventListener('resize', resize);

/* ========== Constants ========== */
const TUNNEL_PAD = 34;
const PLAYER_R = 10;
const FLIP_DUR = 0.15;
const SLOWMO_DUR = 0.6;
const SLOWMO_SCALE = 0.35;
const MAX_FUEL = 3;
const BANK_INTERVAL_MIN = 8;
const BANK_INTERVAL_MAX = 12;
const FREEZE_DUR_MIN = 0.08;
const FREEZE_DUR_MAX = 0.12;

/* ========== Game state ========== */
let state = 'start';
let score, displayScore, bestScore, bestMult;
let multiplier, maxMultReached;
let fuel;
let runTime, speed;
let player;
let gates, hazards, orbs, particles;
let timeScale, slowmoTimer, slowmoActive;
let freezeTimer;
let shakeX, shakeY, shakeMag, shakeTimer;
let nextBankDist, distTravelled;
let lastHazardX;
let tunnelHue;
let prevTime;
let startAnimTime = 0;

bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0;
bestMult = parseInt(localStorage.getItem(LS_MULT_KEY)) || 0;

/* ========== Utility ========== */
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, mn, mx) { return v < mn ? mn : v > mx ? mx : v; }
function rand(a, b) { return a + Math.random() * (b - a); }
function hsl(h, s, l, a) {
  return a !== undefined
    ? `hsla(${((h % 360) + 360) % 360},${s}%,${l}%,${a})`
    : `hsl(${((h % 360) + 360) % 360},${s}%,${l}%)`;
}
function easeInOutQuad(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; }

/* ========== Particles ========== */
function spawnParticles(x, y, count, hue, spdMin, spdMax, life, sMin, sMax) {
  for (let i = 0; i < count; i++) {
    const a = rand(0, Math.PI * 2);
    const spd = rand(spdMin, spdMax);
    particles.push({
      x, y,
      vx: Math.cos(a) * spd,
      vy: Math.sin(a) * spd,
      life, maxLife: life,
      size: rand(sMin || 2, sMax || 5),
      hue: hue + rand(-20, 20),
      sat: rand(80, 100),
      lit: rand(50, 70)
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 350 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    const a = clamp(p.life / p.maxLife, 0, 1);
    ctx.globalAlpha = a;
    ctx.fillStyle = hsl(p.hue, p.sat, p.lit);
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

/* ========== Tunnel helpers ========== */
const tunnelTop = () => TUNNEL_PAD;
const tunnelBot = () => H - TUNNEL_PAD;
const tunnelH = () => H - TUNNEL_PAD * 2;

/* ========== Player factory ========== */
function createPlayer() {
  return {
    x: W * 0.18,
    y: H * 0.5,
    vy: 0,
    onGround: true,
    flipping: false,
    flipTimer: 0,
    flipFrom: 0,
    flipTo: 0,
    hue: 180,
    trail: []
  };
}

/* ========== Difficulty curve ========== */
function diff() {
  const t = runTime;
  return {
    speed: 180 + t * 3.0,
    gateRadius: clamp(28 - t * 0.16, 14, 28),
    gateSpacing: clamp(210 - t * 1.2, 120, 210),
    crushGap: clamp(88 - t * 0.55, 44, 88),
    hazardProb: clamp(0.013 + t * 0.0004, 0.013, 0.05),
    telegraphTime: clamp(1.2 - t * 0.007, 0.5, 1.2),
    laserProb: clamp(0.32 + t * 0.003, 0.32, 0.58),
    driftAmp: clamp(4 + t * 0.12, 4, 16)
  };
}

/* ========== Init run ========== */
function initRun() {
  score = 0;
  displayScore = 0;
  multiplier = 1;
  maxMultReached = 1;
  fuel = 1;
  runTime = 0;
  speed = 180;
  player = createPlayer();
  gates = [];
  hazards = [];
  orbs = [];
  particles = [];
  timeScale = 1;
  slowmoTimer = 0;
  slowmoActive = false;
  freezeTimer = 0;
  shakeX = 0;
  shakeY = 0;
  shakeMag = 0;
  shakeTimer = 0;
  distTravelled = 0;
  nextBankDist = rand(BANK_INTERVAL_MIN, BANK_INTERVAL_MAX) * 180;
  lastHazardX = W + 300;
  tunnelHue = 200;

  // Seed initial gates
  for (let x = W + 80; x < W + 650; x += rand(130, 190)) {
    spawnGate(x, false);
  }
}

/* ========== Gate spawning ========== */
function spawnGate(x, isBank) {
  const d = diff();
  const margin = 42;
  const yy = rand(tunnelTop() + margin, tunnelBot() - margin);
  gates.push({
    x, y: yy,
    radius: isBank ? 30 : d.gateRadius,
    isBank,
    passed: false,
    hue: isBank ? 50 : rand(160, 300)
  });
}

/* ========== Hazard spawning ========== */
function spawnLaser(x) {
  const d = diff();
  const fromTop = Math.random() < 0.5;
  const len = rand(tunnelH() * 0.3, tunnelH() * 0.52);
  hazards.push({
    type: 'laser',
    x, y: fromTop ? tunnelTop() : tunnelBot() - len,
    w: 6, h: len,
    telegraph: d.telegraphTime,
    telegraphMax: d.telegraphTime,
    active: false,
    nearMissed: false,
    hue: 0
  });
}

function spawnCrusher(x) {
  const d = diff();
  const gap = d.crushGap;
  const topH = rand(22, tunnelH() - gap - 22);
  hazards.push({
    type: 'crusher',
    x, w: 28,
    topH,
    botY: tunnelTop() + topH + gap,
    gap,
    telegraph: d.telegraphTime,
    telegraphMax: d.telegraphTime,
    active: false,
    nearMissed: false,
    hue: 30
  });
}

/* ========== Fuel Orb spawning ========== */
function spawnOrb(x) {
  const y = rand(tunnelTop() + 30, tunnelBot() - 30);
  orbs.push({ x, y, radius: 8, collected: false, hue: 120, pulse: 0 });
}

/* ========== Collision ========== */
function circleAABB(cx, cy, cr, rx, ry, rw, rh) {
  const nx = clamp(cx, rx, rx + rw);
  const ny = clamp(cy, ry, ry + rh);
  const dx = cx - nx, dy = cy - ny;
  return dx * dx + dy * dy < cr * cr;
}

function dist2d(x1, y1, x2, y2) {
  const dx = x1 - x2, dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

/* ========== Screen shake ========== */
function triggerShake(mag, dur) {
  shakeMag = mag;
  shakeTimer = dur;
}

/* ========== Input ========== */
function handleInput() {
  if (state === 'start') {
    state = 'playing';
    initRun();
    return;
  }
  if (state === 'gameover') {
    state = 'playing';
    initRun();
    return;
  }
  if (state === 'playing') {
    if (player.flipping) {
      // Mid-flip: slow-mo if fuel available
      if (fuel >= 1 && !slowmoActive) {
        fuel--;
        slowmoActive = true;
        slowmoTimer = SLOWMO_DUR;
        timeScale = SLOWMO_SCALE;
        spawnParticles(player.x, player.y, 8, 280, 40, 100, 0.4, 2, 4);
      }
      return;
    }
    // Start flip
    player.flipping = true;
    player.flipTimer = 0;
    player.flipFrom = player.y;
    if (player.onGround) {
      player.flipTo = tunnelTop() + PLAYER_R + 2;
    } else {
      player.flipTo = tunnelBot() - PLAYER_R - 2;
    }
    player.onGround = !player.onGround;
    player.vy = 0;
    spawnParticles(player.x, player.y, 12, player.hue, 60, 180, 0.35, 2, 5);
  }
}

canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handleInput(); });
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleInput(); }
});

/* ========== Update ========== */
function update(dt) {
  if (freezeTimer > 0) { freezeTimer -= dt; return; }

  const gdt = dt * timeScale;
  runTime += gdt;
  const d = diff();
  speed = d.speed;

  // Slow-mo countdown
  if (slowmoActive) {
    slowmoTimer -= dt;
    if (slowmoTimer <= 0) {
      slowmoActive = false;
      timeScale = 1;
    }
  }

  // Shake
  if (shakeTimer > 0) {
    shakeTimer -= dt;
    shakeX = (Math.random() - 0.5) * shakeMag * 2;
    shakeY = (Math.random() - 0.5) * shakeMag * 2;
    shakeMag *= 0.9;
  } else {
    shakeX = 0;
    shakeY = 0;
  }

  // Hue cycling
  player.hue = (player.hue + 55 * gdt) % 360;
  tunnelHue = (tunnelHue + 12 * gdt) % 360;

  // Player flip / position
  if (player.flipping) {
    player.flipTimer += gdt;
    const t = clamp(player.flipTimer / FLIP_DUR, 0, 1);
    player.y = lerp(player.flipFrom, player.flipTo, easeInOutQuad(t));
    if (t >= 1) {
      player.flipping = false;
      player.y = player.flipTo;
    }
  } else {
    const driftAmp = d.driftAmp;
    const target = player.onGround ? tunnelBot() - PLAYER_R - 2 : tunnelTop() + PLAYER_R + 2;
    const drift = Math.sin(runTime * 2.5) * driftAmp * 0.12;
    player.y = lerp(player.y, target + drift, 8 * gdt);
  }

  // Trail
  player.trail.push({ x: player.x, y: player.y, a: 1, hue: player.hue });
  if (player.trail.length > 24) player.trail.shift();
  for (const tr of player.trail) tr.a -= 2.5 * gdt;

  // Distance
  const moveDist = speed * gdt;
  distTravelled += moveDist;

  // Score tick
  score += speed * gdt * 0.02 * multiplier;
  displayScore = lerp(displayScore, score, 6 * dt);

  // Move entities left
  for (const g of gates) g.x -= moveDist;
  for (const h of hazards) h.x -= moveDist;
  for (const o of orbs) o.x -= moveDist;

  // Spawn gates
  let rightmostGate = 0;
  for (const g of gates) if (g.x > rightmostGate) rightmostGate = g.x;
  if (rightmostGate < W + 80) {
    const spacing = rand(d.gateSpacing, d.gateSpacing + 50);
    const nx = rightmostGate + spacing;
    if (distTravelled >= nextBankDist) {
      spawnGate(nx, true);
      nextBankDist = distTravelled + rand(BANK_INTERVAL_MIN, BANK_INTERVAL_MAX) * speed;
    } else {
      spawnGate(nx, false);
    }
  }

  // Spawn hazards with fairness
  const minLeadDist = player.x + speed * 0.85;
  const minSpacing = speed * 0.55;
  if (Math.random() < d.hazardProb * gdt * 60) {
    const hx = W + rand(50, 140);
    if (hx >= minLeadDist && hx - lastHazardX >= minSpacing) {
      let safeToSpawn = true;
      for (const g of gates) {
        if (Math.abs(g.x - hx) < 55) { safeToSpawn = false; break; }
      }
      if (safeToSpawn) {
        if (Math.random() < d.laserProb) spawnLaser(hx);
        else spawnCrusher(hx);
        lastHazardX = hx;
      }
    }
  }

  // Spawn orbs
  if (Math.random() < 0.005 * gdt * 60) {
    const ox = W + rand(60, 150);
    let safe = true;
    for (const h of hazards) { if (Math.abs(h.x - ox) < 40) { safe = false; break; } }
    if (safe) spawnOrb(ox);
  }

  // Update hazards
  for (let i = hazards.length - 1; i >= 0; i--) {
    const h = hazards[i];
    if (h.telegraph > 0) {
      h.telegraph -= gdt;
      if (h.telegraph <= 0) h.active = true;
    }
    if (h.x < -70) { hazards.splice(i, 1); continue; }
    if (!h.active) continue;

    let hit = false;
    if (h.type === 'laser') {
      hit = circleAABB(player.x, player.y, PLAYER_R - 1, h.x - h.w / 2, h.y, h.w, h.h);
      if (!hit && !h.nearMissed) {
        const expanded = 14;
        if (circleAABB(player.x, player.y, PLAYER_R + expanded, h.x - h.w / 2, h.y, h.w, h.h)) {
          h.nearMissed = true;
          score += 15 * multiplier;
          fuel = Math.min(MAX_FUEL, fuel + 0.25);
          spawnParticles(player.x, player.y, 6, 60, 30, 80, 0.3, 1, 3);
          triggerShake(2, 0.1);
        }
      }
    } else if (h.type === 'crusher') {
      const topHit = circleAABB(player.x, player.y, PLAYER_R - 1, h.x - h.w / 2, tunnelTop(), h.w, h.topH);
      const botHit = circleAABB(player.x, player.y, PLAYER_R - 1, h.x - h.w / 2, h.botY, h.w, tunnelBot() - h.botY);
      hit = topHit || botHit;
      if (!hit && !h.nearMissed) {
        const inXRange = player.x > h.x - h.w / 2 - PLAYER_R - 10 && player.x < h.x + h.w / 2 + PLAYER_R + 10;
        if (inXRange && player.y > tunnelTop() + h.topH - 6 && player.y < h.botY + 6) {
          h.nearMissed = true;
          score += 15 * multiplier;
          fuel = Math.min(MAX_FUEL, fuel + 0.25);
          spawnParticles(player.x, player.y, 6, 60, 30, 80, 0.3, 1, 3);
          triggerShake(2, 0.1);
        }
      }
    }

    if (hit) { die(); return; }
  }

  // Gate collision
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    if (g.x < -60) { gates.splice(i, 1); continue; }
    if (g.passed) continue;
    if (g.x < player.x) {
      g.passed = true;
      const dd = dist2d(player.x, player.y, g.x, g.y);
      if (g.isBank) {
        const bonus = Math.floor(multiplier * 50);
        score += bonus;
        spawnParticles(g.x, g.y, 22, 50, 80, 200, 0.5, 3, 7);
        triggerShake(4, 0.15);
        multiplier = 1;
      } else {
        if (dd < g.radius * 0.75) {
          multiplier = Math.min(10, multiplier + 1);
          maxMultReached = Math.max(maxMultReached, multiplier);
          spawnParticles(g.x, g.y, 16, g.hue, 60, 150, 0.4, 2, 5);
          score += 25 * multiplier;
        } else if (dd < g.radius * 1.4) {
          score += 5;
          spawnParticles(g.x, g.y, 5, g.hue, 30, 60, 0.25, 1, 3);
        } else {
          if (multiplier > 1) {
            spawnParticles(g.x, g.y, 10, 0, 40, 100, 0.35, 2, 4);
          }
          multiplier = 1;
        }
      }
    }
  }

  // Orb collision
  for (let i = orbs.length - 1; i >= 0; i--) {
    const o = orbs[i];
    o.pulse += gdt * 4;
    if (o.x < -30) { orbs.splice(i, 1); continue; }
    if (!o.collected && dist2d(player.x, player.y, o.x, o.y) < PLAYER_R + o.radius) {
      o.collected = true;
      fuel = Math.min(MAX_FUEL, fuel + 1);
      spawnParticles(o.x, o.y, 10, 120, 50, 120, 0.35, 2, 5);
      orbs.splice(i, 1);
    }
  }

  // Tunnel wall collision
  if (player.y - PLAYER_R < tunnelTop() + 1 || player.y + PLAYER_R > tunnelBot() - 1) {
    die();
    return;
  }

  updateParticles(gdt);
}

/* ========== Die ========== */
function die() {
  state = 'gameover';
  spawnParticles(player.x, player.y, 45, player.hue, 80, 300, 0.7, 3, 8);
  spawnParticles(player.x, player.y, 25, 0, 60, 220, 0.5, 2, 6);
  triggerShake(14, 0.45);
  freezeTimer = rand(FREEZE_DUR_MIN, FREEZE_DUR_MAX);

  const finalScore = Math.floor(score);
  if (finalScore > bestScore) {
    bestScore = finalScore;
    localStorage.setItem(LS_KEY, bestScore);
  }
  if (maxMultReached > bestMult) {
    bestMult = maxMultReached;
    localStorage.setItem(LS_MULT_KEY, bestMult);
  }
}

/* ========== Drawing ========== */
function draw() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, '#0b0f1a');
  bg.addColorStop(0.5, '#0d1225');
  bg.addColorStop(1, '#080c18');
  ctx.fillStyle = bg;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  if (state === 'start') {
    drawStartScreen();
    ctx.restore();
    return;
  }

  drawTunnel();
  drawHazards();
  drawGates();
  drawOrbs();
  drawTrail();
  drawPlayer();
  drawParticles();

  if (slowmoActive) drawSlowMoFX();

  drawHUD();

  if (state === 'gameover') drawGameOver();

  ctx.restore();
}

/* ---- Tunnel ---- */
function drawTunnel() {
  // Top wall
  const tg = ctx.createLinearGradient(0, 0, 0, TUNNEL_PAD);
  tg.addColorStop(0, hsl(tunnelHue, 50, 6));
  tg.addColorStop(1, hsl(tunnelHue, 70, 14, 0.7));
  ctx.fillStyle = tg;
  ctx.fillRect(0, 0, W, TUNNEL_PAD);

  // Bottom wall
  const bg2 = ctx.createLinearGradient(0, H - TUNNEL_PAD, 0, H);
  bg2.addColorStop(0, hsl(tunnelHue + 30, 70, 14, 0.7));
  bg2.addColorStop(1, hsl(tunnelHue + 30, 50, 6));
  ctx.fillStyle = bg2;
  ctx.fillRect(0, H - TUNNEL_PAD, W, TUNNEL_PAD);

  // Neon edge lines
  ctx.strokeStyle = hsl(tunnelHue, 100, 50, 0.45);
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, tunnelTop());
  ctx.lineTo(W, tunnelTop());
  ctx.stroke();

  ctx.strokeStyle = hsl(tunnelHue + 30, 100, 50, 0.45);
  ctx.beginPath();
  ctx.moveTo(0, tunnelBot());
  ctx.lineTo(W, tunnelBot());
  ctx.stroke();

  // Scrolling grid
  ctx.globalAlpha = 0.05;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 0.5;
  const gridSp = 40;
  const off = distTravelled % gridSp;
  for (let x = -off; x < W; x += gridSp) {
    ctx.beginPath();
    ctx.moveTo(x, tunnelTop());
    ctx.lineTo(x, tunnelBot());
    ctx.stroke();
  }
  for (let y = tunnelTop(); y <= tunnelBot(); y += gridSp) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

/* ---- Gates ---- */
function drawGates() {
  for (const g of gates) {
    if (g.x < -50 || g.x > W + 50) continue;
    const r = g.radius;
    const pulseR = r + Math.sin(runTime * 5 + g.x * 0.03) * 2.5;

    ctx.shadowBlur = 14;
    if (g.isBank) {
      ctx.strokeStyle = hsl(50, 100, 60, 0.9);
      ctx.lineWidth = 3.5;
      ctx.shadowColor = hsl(50, 100, 55);
      ctx.beginPath();
      ctx.arc(g.x, g.y, pulseR, 0, Math.PI * 2);
      ctx.stroke();
      // Inner double ring
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = hsl(50, 90, 70, 0.5);
      ctx.beginPath();
      ctx.arc(g.x, g.y, pulseR * 0.65, 0, Math.PI * 2);
      ctx.stroke();
      // $ text
      ctx.shadowBlur = 0;
      ctx.fillStyle = hsl(50, 100, 75);
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('$', g.x, g.y);
    } else {
      ctx.strokeStyle = hsl(g.hue, 100, 55, 0.8);
      ctx.lineWidth = 2.5;
      ctx.shadowColor = hsl(g.hue, 100, 55);
      ctx.beginPath();
      ctx.arc(g.x, g.y, pulseR, 0, Math.PI * 2);
      ctx.stroke();
      // Inner glow ring
      ctx.strokeStyle = hsl(g.hue, 70, 65, 0.25);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(g.x, g.y, pulseR * 0.55, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.shadowBlur = 0;
  }
}

/* ---- Hazards ---- */
function drawHazards() {
  for (const h of hazards) {
    if (h.x < -70 || h.x > W + 70) continue;

    if (h.type === 'laser') {
      if (!h.active) {
        // Telegraph
        const t = 1 - h.telegraph / h.telegraphMax;
        ctx.globalAlpha = 0.12 + t * 0.35;
        ctx.fillStyle = hsl(0, 100, 50);
        ctx.fillRect(h.x - h.w / 2 - 3, h.y, h.w + 6, h.h);
        // Warning stripes
        ctx.strokeStyle = hsl(0, 100, 60, 0.5 * t);
        ctx.lineWidth = 1;
        const stripeGap = 10;
        for (let yy = h.y; yy < h.y + h.h; yy += stripeGap) {
          ctx.beginPath();
          ctx.moveTo(h.x - h.w / 2 - 5, yy);
          ctx.lineTo(h.x + h.w / 2 + 5, yy);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      } else {
        // Active laser
        ctx.shadowColor = '#f00';
        ctx.shadowBlur = 18;
        ctx.fillStyle = hsl(0, 100, 55);
        ctx.fillRect(h.x - h.w / 2, h.y, h.w, h.h);
        ctx.fillStyle = hsl(0, 80, 85);
        ctx.fillRect(h.x - 1, h.y, 2, h.h);
        ctx.shadowBlur = 0;
      }
    } else if (h.type === 'crusher') {
      const topY = tunnelTop();
      const botY2 = h.botY;
      const botH = tunnelBot() - botY2;
      if (!h.active) {
        const t = 1 - h.telegraph / h.telegraphMax;
        ctx.globalAlpha = 0.12 + t * 0.35;
        ctx.fillStyle = hsl(30, 80, 42);
        ctx.fillRect(h.x - h.w / 2, topY, h.w, h.topH);
        ctx.fillRect(h.x - h.w / 2, botY2, h.w, botH);
        // Arrows
        ctx.fillStyle = hsl(30, 100, 60, t * 0.8);
        const as = 5;
        ctx.beginPath();
        ctx.moveTo(h.x, topY + h.topH + as);
        ctx.lineTo(h.x - as, topY + h.topH);
        ctx.lineTo(h.x + as, topY + h.topH);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(h.x, botY2 - as);
        ctx.lineTo(h.x - as, botY2);
        ctx.lineTo(h.x + as, botY2);
        ctx.fill();
        ctx.globalAlpha = 1;
      } else {
        ctx.shadowColor = hsl(30, 100, 50);
        ctx.shadowBlur = 8;
        ctx.fillStyle = hsl(30, 85, 48);
        ctx.fillRect(h.x - h.w / 2, topY, h.w, h.topH);
        ctx.fillRect(h.x - h.w / 2, botY2, h.w, botH);
        // Teeth
        ctx.fillStyle = hsl(30, 75, 62);
        const ts = 4;
        for (let tx = h.x - h.w / 2; tx < h.x + h.w / 2; tx += ts * 2) {
          ctx.beginPath();
          ctx.moveTo(tx, topY + h.topH);
          ctx.lineTo(tx + ts, topY + h.topH + ts);
          ctx.lineTo(tx + ts * 2, topY + h.topH);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(tx, botY2);
          ctx.lineTo(tx + ts, botY2 - ts);
          ctx.lineTo(tx + ts * 2, botY2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }
    }
  }
}

/* ---- Orbs ---- */
function drawOrbs() {
  for (const o of orbs) {
    if (o.x < -20 || o.x > W + 20) continue;
    const pulse = 1 + Math.sin(o.pulse) * 0.15;
    const r = o.radius * pulse;
    // Outer glow
    ctx.fillStyle = hsl(120, 80, 50, 0.2);
    ctx.beginPath();
    ctx.arc(o.x, o.y, r + 6, 0, Math.PI * 2);
    ctx.fill();
    // Body
    ctx.shadowColor = hsl(120, 100, 55);
    ctx.shadowBlur = 10;
    ctx.fillStyle = hsl(120, 100, 58);
    ctx.beginPath();
    ctx.arc(o.x, o.y, r, 0, Math.PI * 2);
    ctx.fill();
    // Highlight
    ctx.shadowBlur = 0;
    ctx.fillStyle = hsl(120, 70, 82);
    ctx.beginPath();
    ctx.arc(o.x - 2, o.y - 2, r * 0.35, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* ---- Trail ---- */
function drawTrail() {
  if (!player || !player.trail) return;

  if (slowmoActive) {
    // Chromatic aberration
    for (let i = 0; i < player.trail.length; i++) {
      const t = player.trail[i];
      if (t.a <= 0) continue;
      const a = clamp(t.a, 0, 1) * 0.25;
      const sz = PLAYER_R * (0.25 + i / player.trail.length * 0.5);
      ctx.globalAlpha = a;
      ctx.fillStyle = hsl(0, 100, 60);
      ctx.beginPath();
      ctx.arc(t.x - 2, t.y - 1, sz, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = hsl(180, 100, 60);
      ctx.beginPath();
      ctx.arc(t.x + 2, t.y + 1, sz, 0, Math.PI * 2);
      ctx.fill();
    }
  } else {
    for (let i = 0; i < player.trail.length; i++) {
      const t = player.trail[i];
      if (t.a <= 0) continue;
      ctx.globalAlpha = clamp(t.a, 0, 1) * 0.35;
      ctx.fillStyle = hsl(t.hue, 80, 55);
      ctx.beginPath();
      ctx.arc(t.x, t.y, PLAYER_R * (0.25 + i / player.trail.length * 0.4), 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

/* ---- Player ---- */
function drawPlayer() {
  if (!player) return;
  ctx.shadowColor = hsl(player.hue, 100, 58);
  ctx.shadowBlur = 16;
  ctx.fillStyle = hsl(player.hue, 90, 55);
  ctx.beginPath();
  ctx.arc(player.x, player.y, PLAYER_R, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = hsl(player.hue, 60, 82);
  ctx.beginPath();
  ctx.arc(player.x - 2, player.y - 2, PLAYER_R * 0.4, 0, Math.PI * 2);
  ctx.fill();
}

/* ---- Slow-mo vignette ---- */
function drawSlowMoFX() {
  const vg = ctx.createRadialGradient(W / 2, H / 2, H * 0.18, W / 2, H / 2, H * 0.65);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(20,0,50,0.35)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);
}

/* ---- HUD ---- */
function drawHUD() {
  const sc = Math.floor(displayScore);

  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 18px monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(sc, 12, 8);

  // Best
  ctx.fillStyle = '#556';
  ctx.font = '11px monospace';
  ctx.fillText('BEST ' + bestScore, 12, 30);

  // Multiplier
  const multHue = lerp(180, 300, clamp((multiplier - 1) / 9, 0, 1));
  ctx.fillStyle = hsl(multHue, 100, 60);
  ctx.font = 'bold 16px monospace';
  ctx.textAlign = 'right';
  ctx.fillText('x' + multiplier, W - 12, 8);

  // Fuel pips
  const pipY = 30;
  const pipW = 14, pipH = 7, pipGap = 3;
  const totalFuelW = MAX_FUEL * (pipW + pipGap) - pipGap;
  const fuelStartX = W - 12 - totalFuelW;

  for (let i = 0; i < MAX_FUEL; i++) {
    const px = fuelStartX + i * (pipW + pipGap);
    ctx.fillStyle = i < Math.floor(fuel) ? hsl(180, 90, 52) : 'rgba(255,255,255,0.12)';
    ctx.fillRect(px, pipY, pipW, pipH);
    if (i < Math.floor(fuel)) {
      ctx.fillStyle = hsl(180, 70, 78);
      ctx.fillRect(px + 1, pipY + 1, pipW - 2, 2);
    }
  }

  // Fractional pip
  const frac = fuel - Math.floor(fuel);
  const fi = Math.floor(fuel);
  if (frac > 0.02 && fi < MAX_FUEL) {
    const px = fuelStartX + fi * (pipW + pipGap);
    ctx.fillStyle = hsl(180, 90, 52, frac * 0.8);
    ctx.fillRect(px, pipY, pipW * frac, pipH);
  }
}

/* ---- Start screen ---- */
function drawStartScreen() {
  startAnimTime += 0.016;

  // Subtle grid bg
  ctx.globalAlpha = 0.035;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 0.5;
  for (let x = 0; x < W; x += 28) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y < H; y += 28) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Floating particles (decorative)
  const t = startAnimTime;
  for (let i = 0; i < 6; i++) {
    const px = W * 0.2 + Math.sin(t * 0.7 + i * 1.3) * W * 0.3;
    const py = H * 0.35 + Math.cos(t * 0.5 + i * 0.9) * H * 0.15;
    const hueP = (190 + i * 30 + t * 20) % 360;
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = hsl(hueP, 100, 60);
    ctx.beginPath();
    ctx.arc(px, py, 3 + Math.sin(t + i) * 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Title
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = hsl(190, 100, 55);
  ctx.shadowBlur = 25;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 36px monospace';
  ctx.fillText('GRAVITY', W / 2, H * 0.28);
  ctx.fillStyle = hsl(190, 100, 65);
  ctx.font = 'bold 38px monospace';
  ctx.fillText('FLIP', W / 2, H * 0.28 + 42);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.fillStyle = hsl(320, 80, 58);
  ctx.font = '13px monospace';
  ctx.fillText('H E A T L I N E', W / 2, H * 0.28 + 78);

  // Instructions
  ctx.fillStyle = '#778';
  ctx.font = '12px monospace';
  const iy = H * 0.52;
  const lines = [
    'Tap / Space to flip gravity',
    'Thread heat gates for combo',
    'Tap mid-flip for slow-mo (costs fuel)',
    'Collect green orbs to refuel',
    'Bank gates ($) cash out your combo'
  ];
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], W / 2, iy + i * 20);
  }

  // Tap to start
  const pulseA = 0.45 + Math.sin(Date.now() / 350) * 0.35;
  ctx.globalAlpha = clamp(pulseA, 0.1, 0.9);
  ctx.fillStyle = hsl(190, 100, 68);
  ctx.font = 'bold 16px monospace';
  ctx.fillText('TAP TO START', W / 2, H * 0.78);
  ctx.globalAlpha = 1;

  if (bestScore > 0) {
    ctx.fillStyle = '#445';
    ctx.font = '12px monospace';
    ctx.fillText('Best: ' + bestScore, W / 2, H * 0.85);
  }
}

/* ---- Game over screen ---- */
function drawGameOver() {
  ctx.fillStyle = 'rgba(5,8,18,0.78)';
  ctx.fillRect(-20, -20, W + 40, H + 40);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = hsl(0, 90, 50);
  ctx.shadowBlur = 18;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 30px monospace';
  ctx.fillText('GAME OVER', W / 2, H * 0.28);
  ctx.shadowBlur = 0;

  // Score
  const sc = Math.floor(score);
  ctx.fillStyle = '#556';
  ctx.font = '11px monospace';
  ctx.fillText('SCORE', W / 2, H * 0.39);
  ctx.fillStyle = hsl(190, 90, 65);
  ctx.font = 'bold 28px monospace';
  ctx.fillText(sc, W / 2, H * 0.43 + 4);

  // Best
  ctx.fillStyle = '#556';
  ctx.font = '11px monospace';
  ctx.fillText('BEST', W / 2, H * 0.53);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 22px monospace';
  ctx.fillText(bestScore, W / 2, H * 0.57);

  // Max multiplier
  ctx.fillStyle = hsl(270, 85, 62);
  ctx.font = 'bold 14px monospace';
  ctx.fillText('x' + maxMultReached + ' max combo', W / 2, H * 0.66);

  // New best indicator
  if (Math.floor(score) >= bestScore && bestScore > 0) {
    ctx.fillStyle = hsl(50, 100, 60);
    ctx.font = 'bold 13px monospace';
    ctx.fillText('NEW BEST!', W / 2, H * 0.72);
  }

  // Tap to retry
  const pulseA = 0.45 + Math.sin(Date.now() / 350) * 0.35;
  ctx.globalAlpha = clamp(pulseA, 0.1, 0.9);
  ctx.fillStyle = hsl(190, 100, 68);
  ctx.font = 'bold 16px monospace';
  ctx.fillText('TAP TO RETRY', W / 2, H * 0.82);
  ctx.globalAlpha = 1;
}

/* ========== Main loop ========== */
prevTime = performance.now();

function loop(now) {
  requestAnimationFrame(loop);
  const rawDt = (now - prevTime) / 1000;
  prevTime = now;
  const dt = Math.min(rawDt, 1 / 30);

  if (state === 'playing') {
    update(dt);
  }
  draw();
}

requestAnimationFrame(loop);

})();
</script>
</body>
</html>
