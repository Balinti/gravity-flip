<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity up/down while dodging obstacles. Collect stars for bonus points in this hyper-casual endless runner.">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og.jpg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity up/down while dodging obstacles. Collect stars for bonus points in this hyper-casual endless runner.">
<meta name="twitter:image" content="https://balinti.github.io/gravity-flip/og.jpg">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,sans-serif;display:flex;justify-content:center;align-items:center;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}
#wrap{position:relative;width:100%;max-width:420px;height:100vh;height:100dvh;max-height:750px;display:flex;flex-direction:column;align-items:center}
canvas{display:block;width:100%;height:100%;cursor:pointer}
#info{position:absolute;bottom:4px;left:8px;right:8px;text-align:center;color:rgba(255,255,255,0.15);font-size:10px;line-height:1.4;pointer-events:none;z-index:2}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="info">Gravity Flip: Polarity Rush &mdash; Tap or press Space to flip gravity between floor and ceiling. Dodge solid blocks, pass through polarity gates on the correct side (Cyan=ceiling, Magenta=floor). Collect stars to fill the Flux Meter and trigger bullet-time. Build combos by passing hazards without flipping. Free to play, no download required.</div>
</div>
<script>
'use strict';
(()=>{

/* ═══════════════════════════════════════════════════════════════
   GRAVITY FLIP: POLARITY RUSH
   Hyper-casual HTML5 canvas endless runner
   ═══════════════════════════════════════════════════════════════ */

// ── Constants ────────────────────────────────────────────────
const BW = 420, BH = 750;
const CEIL_Y = 60, FLOOR_Y = BH - 60;
const LANE_CEIL = CEIL_Y + 30, LANE_FLOOR = FLOOR_Y - 30;
const PLAY_H = FLOOR_Y - CEIL_Y;
const PLAYER_X = 90, PLAYER_R = 14;
const BASE_SPEED = 210, MAX_SPEED = 500, SPEED_RAMP = 0.85;
const SPRING_K = 22, SPRING_DAMP = 0.78;
const STAR_R = 10, FLUX_MAX = 6;
const BULLET_DUR = 1.5, BULLET_SCALE = 0.32;
const GRAZE_DIST = 32;
const BLOCK_SIZE = 38;
const GATE_W = 30;
const LS_KEY = 'gflip_polarity_best';

// ── Canvas ───────────────────────────────────────────────────
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let dpr = 1, cw, ch, scale, offsetX, offsetY;

function resize() {
  const wrap = document.getElementById('wrap');
  const bw = wrap.clientWidth, bh = wrap.clientHeight;
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  cw = bw; ch = bh;
  cvs.width = bw * dpr; cvs.height = bh * dpr;
  cvs.style.width = bw + 'px'; cvs.style.height = bh + 'px';
  scale = Math.min(bw / BW, bh / BH);
  offsetX = (bw - BW * scale) / 2;
  offsetY = (bh - BH * scale) / 2;
}
window.addEventListener('resize', resize);
resize();

// ── State ────────────────────────────────────────────────────
let state = 'start';
let score, bestScore, combo, comboMult;
let playerY, playerVY, onFloor, targetY;
let speed, elapsed, totalDist;
let hazards, stars, particles, texts;
let fluxMeter, bulletTime, bulletTimer;
let shakeX, shakeY, shakeDur, shakeIntensity;
let deathFreezeTimer;
let spawnTimer, spawnCooldown;
let hue, gridOffset;

bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0;

// ── Helpers ──────────────────────────────────────────────────
const rand = (a, b) => a + Math.random() * (b - a);
const randInt = (a, b) => Math.floor(rand(a, b + 0.999));
const lerp = (a, b, t) => a + (b - a) * t;
const clamp = (v, lo, hi) => v < lo ? lo : v > hi ? hi : v;

// ── Init / Reset ─────────────────────────────────────────────
function initGame() {
  score = 0; combo = 0; comboMult = 1;
  playerY = LANE_FLOOR; playerVY = 0;
  onFloor = true; targetY = LANE_FLOOR;
  speed = BASE_SPEED; elapsed = 0; totalDist = 0;
  hazards = []; stars = []; particles = []; texts = [];
  fluxMeter = 0; bulletTime = false; bulletTimer = 0;
  shakeX = 0; shakeY = 0; shakeDur = 0; shakeIntensity = 0;
  deathFreezeTimer = 0;
  spawnTimer = 1.0; spawnCooldown = 0;
  hue = 190; gridOffset = 0;
}

// ── Input ────────────────────────────────────────────────────
function doInput() {
  if (state === 'start') {
    state = 'playing';
    initGame();
    return;
  }
  if (state === 'gameover') {
    if (deathFreezeTimer > 0) return;
    state = 'playing';
    initGame();
    return;
  }
  if (state === 'playing') flipGravity();
}

function flipGravity() {
  onFloor = !onFloor;
  targetY = onFloor ? LANE_FLOOR : LANE_CEIL;
  playerVY = onFloor ? 200 : -200; // Initial kick
  combo = 0;
  comboMult = 1;
}

cvs.addEventListener('pointerdown', (e) => { e.preventDefault(); doInput(); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); doInput(); }
});

// ── Spawning ─────────────────────────────────────────────────
function spawnBlock(lane, xOff) {
  const y = lane === 'floor' ? LANE_FLOOR : LANE_CEIL;
  hazards.push({
    x: BW + 50 + (xOff || 0), y, w: BLOCK_SIZE, h: BLOCK_SIZE,
    type: 'block', lane, scored: false, grazed: false
  });
}

function spawnGate(color, xOff) {
  const safeLane = color === 'cyan' ? 'ceil' : 'floor';
  hazards.push({
    x: BW + 50 + (xOff || 0), y: BH / 2,
    w: GATE_W, h: PLAY_H, type: 'gate',
    color, safeLane, scored: false, checked: false
  });
}

function spawnStar(lane, xOff) {
  const y = lane === 'floor' ? LANE_FLOOR : LANE_CEIL;
  stars.push({ x: BW + 50 + (xOff || 0), y, r: STAR_R, collected: false });
}

const PATTERNS = [
  // Simple single blocks
  () => { spawnBlock('floor'); },
  () => { spawnBlock('ceil'); },
  // Simple gates
  () => { spawnGate('cyan'); },
  () => { spawnGate('magenta'); },
  // Block + opposite star
  () => { spawnBlock('floor'); spawnStar('ceil'); },
  () => { spawnBlock('ceil'); spawnStar('floor'); },
  // Staggered blocks (ABAB)
  () => { spawnBlock('floor'); spawnBlock('ceil', 130); },
  () => { spawnBlock('ceil'); spawnBlock('floor', 130); },
  // Gate + block combo
  () => { spawnGate('cyan'); spawnBlock('floor', 150); },
  () => { spawnGate('magenta'); spawnBlock('ceil', 150); },
  // Star run
  () => { spawnStar('floor'); spawnStar('ceil', 80); spawnStar('floor', 160); },
  // Gate + star
  () => { spawnGate('cyan'); spawnStar('ceil', 100); },
  () => { spawnGate('magenta'); spawnStar('floor', 100); },
  // Same-side double blocks (fake-out)
  () => { spawnBlock('floor'); spawnBlock('floor', 160); },
  () => { spawnBlock('ceil'); spawnBlock('ceil', 160); },
  // Triple stagger
  () => { spawnBlock('floor'); spawnBlock('ceil', 120); spawnBlock('floor', 240); },
  () => { spawnBlock('ceil'); spawnBlock('floor', 120); spawnBlock('ceil', 240); },
  // Gate sandwich
  () => { spawnBlock('floor', 0); spawnGate('magenta', 180); spawnBlock('ceil', 340); },
  () => { spawnBlock('ceil', 0); spawnGate('cyan', 180); spawnBlock('floor', 340); },
];

function spawnPattern() {
  // Difficulty gates which patterns are available
  const maxIdx = Math.min(PATTERNS.length, 4 + Math.floor(elapsed / 8));
  const idx = randInt(0, maxIdx - 1);
  PATTERNS[idx]();
}

// ── Particles ────────────────────────────────────────────────
function emitThruster(dt) {
  if (Math.random() > dt * 60 * 0.65) return;
  const dir = onFloor ? -1 : 1;
  const col = onFloor ? 'cyan' : 'magenta';
  particles.push({
    x: PLAYER_X - PLAYER_R + rand(-4, 2),
    y: playerY + dir * (PLAYER_R - 2),
    vx: rand(-40, -100),
    vy: dir * rand(30, 100),
    life: rand(0.15, 0.4),
    maxLife: 0.4, r: rand(2, 5),
    hue: col === 'cyan' ? 185 : 310,
    sat: 100, light: 60,
    type: 'thrust'
  });
}

function emitStarBurst(x, y) {
  for (let i = 0; i < 14; i++) {
    const a = Math.PI * 2 * i / 14;
    particles.push({
      x, y, vx: Math.cos(a) * rand(80, 220), vy: Math.sin(a) * rand(80, 220),
      life: rand(0.25, 0.55), maxLife: 0.55, r: rand(2, 4),
      hue: 45, sat: 100, light: 65, type: 'star'
    });
  }
}

function emitDeath(x, y) {
  for (let i = 0; i < 35; i++) {
    const a = Math.PI * 2 * i / 35;
    const sp = rand(100, 380);
    particles.push({
      x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
      life: rand(0.4, 1.0), maxLife: 1.0, r: rand(2, 7),
      hue: rand(0, 360), sat: 80, light: 65, type: 'death'
    });
  }
  // Expanding ring
  particles.push({ x, y, vx: 0, vy: 0, life: 0.6, maxLife: 0.6, r: 8, hue: 0, sat: 0, light: 100, type: 'ring' });
}

function emitGraze(x, y) {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x: x + rand(-6, 6), y: y + rand(-6, 6),
      vx: rand(-70, 70), vy: rand(-70, 70),
      life: rand(0.15, 0.35), maxLife: 0.35, r: rand(1.5, 3),
      hue: 55, sat: 100, light: 70, type: 'graze'
    });
  }
}

// ── Shake ────────────────────────────────────────────────────
function triggerShake(intensity, dur) {
  shakeDur = dur;
  shakeIntensity = intensity;
  shakeX = rand(-intensity, intensity);
  shakeY = rand(-intensity, intensity);
}

// ── Float text ───────────────────────────────────────────────
function spawnText(txt, x, y, color, size) {
  texts.push({ txt, x, y, vy: -65, life: 0.9, maxLife: 0.9, color, size: size || 18 });
}

// ── Update ───────────────────────────────────────────────────
function update(rawDt) {
  if (state !== 'playing') return;

  // Death freeze
  if (deathFreezeTimer > 0) { deathFreezeTimer -= rawDt; return; }

  // Bullet time
  let timeScale = 1;
  if (bulletTime) {
    bulletTimer -= rawDt;
    if (bulletTimer <= 0) { bulletTime = false; bulletTimer = 0; }
    else timeScale = BULLET_SCALE;
  }
  const dt = rawDt * timeScale;
  const playerDt = rawDt;

  elapsed += dt;
  hue = (hue + dt * 12) % 360;

  // Speed ramp
  speed = Math.min(BASE_SPEED + elapsed * SPEED_RAMP, MAX_SPEED);
  const moveX = speed * dt;
  totalDist += moveX;
  gridOffset = (gridOffset + moveX) % 60;

  // Player spring physics
  const diff = targetY - playerY;
  playerVY += diff * SPRING_K * playerDt;
  playerVY *= Math.pow(SPRING_DAMP, playerDt * 60);
  playerY += playerVY * playerDt;
  playerY = clamp(playerY, LANE_CEIL, LANE_FLOOR);

  // Spawning
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
    spawnPattern();
    const minT = Math.max(0.45, 1.3 - elapsed * 0.004);
    spawnTimer = rand(minT, minT + 0.55);
  }

  // Move hazards & collisions
  for (let i = hazards.length - 1; i >= 0; i--) {
    const h = hazards[i];
    h.x -= moveX;

    // Off screen left - score it
    if (h.x < -60) {
      if (!h.scored) {
        h.scored = true;
        combo++;
        comboMult = Math.min(1 + Math.floor(combo / 3) * 0.5, 5);
        const pts = Math.ceil(1 * comboMult);
        score += pts;
        if (comboMult > 1) spawnText('x' + comboMult.toFixed(1), 140, playerY - 25, '#0f0', 15);
      }
      hazards.splice(i, 1);
      continue;
    }

    // Skip collision if already scored
    if (h.scored) continue;

    // Check if hazard is near player
    if (h.type === 'block') {
      const bx = h.x, by = h.y;
      const dx = Math.abs(PLAYER_X - bx);
      const dy = Math.abs(playerY - by);
      const hitX = PLAYER_R + h.w / 2 - 5;
      const hitY = PLAYER_R + h.h / 2 - 5;

      if (dx < hitX && dy < hitY) {
        die(); return;
      }

      // Graze check
      if (!h.grazed && dx < GRAZE_DIST + h.w / 2 && dy < GRAZE_DIST + h.h / 2) {
        h.grazed = true;
        spawnText('GRAZE!', PLAYER_X + 35, playerY - 18, '#ff0', 16);
        emitGraze(PLAYER_X + PLAYER_R, playerY);
        triggerShake(2, 0.08);
        score += 1;
      }
    } else if (h.type === 'gate') {
      // Gate collision: player must be on the safe lane
      const inGate = PLAYER_X + PLAYER_R > h.x && PLAYER_X - PLAYER_R < h.x + h.w;
      if (inGate && !h.checked) {
        h.checked = true;
        const playerLane = onFloor ? 'floor' : 'ceil';
        if (playerLane !== h.safeLane) {
          die(); return;
        }
      }
    }
  }

  // Move & collect stars
  for (let i = stars.length - 1; i >= 0; i--) {
    const s = stars[i];
    s.x -= moveX;
    if (s.x < -30) { stars.splice(i, 1); continue; }
    if (!s.collected) {
      const dx = PLAYER_X - s.x, dy = playerY - s.y;
      if (dx * dx + dy * dy < (PLAYER_R + s.r + 4) * (PLAYER_R + s.r + 4)) {
        s.collected = true;
        score += 2;
        fluxMeter = Math.min(fluxMeter + 1, FLUX_MAX);
        emitStarBurst(s.x, s.y);
        spawnText('+2', s.x + 10, s.y - 18, '#ffd700', 17);
        if (fluxMeter >= FLUX_MAX) {
          fluxMeter = 0;
          bulletTime = true;
          bulletTimer = BULLET_DUR;
          spawnText('FLUX!', PLAYER_X + 5, playerY - 42, '#0ff', 22);
          triggerShake(3, 0.12);
        }
        stars.splice(i, 1);
      }
    }
  }

  // Thruster particles
  emitThruster(rawDt);

  // Update particles
  updateParticles(dt, rawDt);

  // Update texts
  for (let i = texts.length - 1; i >= 0; i--) {
    const t = texts[i];
    t.life -= rawDt;
    if (t.life <= 0) { texts.splice(i, 1); continue; }
    t.y += t.vy * rawDt;
  }

  // Shake decay
  if (shakeDur > 0) {
    shakeDur -= rawDt;
    const t = clamp(shakeDur / 0.4, 0, 1);
    shakeX = Math.sin(performance.now() * 0.05) * shakeIntensity * t;
    shakeY = Math.cos(performance.now() * 0.07) * shakeIntensity * t;
    if (shakeDur <= 0) { shakeX = 0; shakeY = 0; }
  }
}

function updateParticles(dt, rawDt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    const pdt = p.type === 'thrust' ? rawDt : dt;
    p.life -= rawDt;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    if (p.type === 'ring') {
      p.r += 350 * rawDt;
    } else {
      p.x += p.vx * pdt;
      p.y += p.vy * pdt;
      if (p.type === 'death') p.vy += 150 * pdt;
    }
  }
}

function die() {
  emitDeath(PLAYER_X, playerY);
  triggerShake(10, 0.45);
  deathFreezeTimer = 0.35;
  if (score > bestScore) { bestScore = Math.floor(score); localStorage.setItem(LS_KEY, bestScore); }
  setTimeout(() => { if (state === 'playing') state = 'gameover'; }, 360);
}

// ── Render ───────────────────────────────────────────────────
function render() {
  ctx.save();
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Shake
  if (shakeDur > 0) ctx.translate(shakeX, shakeY);

  // Background
  const bgGrad = ctx.createLinearGradient(0, 0, 0, BH);
  bgGrad.addColorStop(0, '#080820');
  bgGrad.addColorStop(0.5, '#0a0a1a');
  bgGrad.addColorStop(1, '#180820');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(-20, -20, BW + 40, BH + 40);

  // Bullet-time vignette
  if (bulletTime) {
    const vig = ctx.createRadialGradient(BW / 2, BH / 2, 80, BW / 2, BH / 2, BW * 0.8);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, 'rgba(0, 60, 100, 0.3)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, BW, BH);
  }

  // Scrolling grid
  ctx.strokeStyle = 'rgba(255,255,255,0.025)';
  ctx.lineWidth = 1;
  for (let x = -gridOffset; x < BW + 60; x += 60) {
    ctx.beginPath(); ctx.moveTo(x, CEIL_Y); ctx.lineTo(x, FLOOR_Y); ctx.stroke();
  }

  // Floor / Ceiling lines
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, CEIL_Y); ctx.lineTo(BW, CEIL_Y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, FLOOR_Y); ctx.lineTo(BW, FLOOR_Y); ctx.stroke();

  // Lane background
  ctx.fillStyle = 'rgba(255,255,255,0.015)';
  ctx.fillRect(0, CEIL_Y, BW, PLAY_H);

  if (state === 'start') {
    renderStartScreen();
  } else {
    renderGame();
  }

  ctx.restore();
}

function renderStartScreen() {
  // Title
  ctx.fillStyle = '#fff';
  ctx.font = "bold 46px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('GRAVITY', BW / 2, BH / 2 - 90);

  const tg = ctx.createLinearGradient(BW / 2 - 80, 0, BW / 2 + 80, 0);
  tg.addColorStop(0, '#00ffff');
  tg.addColorStop(1, '#ff00ff');
  ctx.fillStyle = tg;
  ctx.font = "bold 42px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('FLIP', BW / 2, BH / 2 - 38);

  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = "15px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('POLARITY RUSH', BW / 2, BH / 2 + 5);

  // Tap prompt
  const pulse = 0.4 + 0.5 * Math.sin(performance.now() / 350);
  ctx.fillStyle = `rgba(255,255,255,${pulse})`;
  ctx.font = "20px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('Tap to Start', BW / 2, BH / 2 + 70);

  // Best
  if (bestScore > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = "14px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText('Best: ' + bestScore, BW / 2, BH / 2 + 110);
  }

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.22)';
  ctx.font = "12px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('Tap / Space to flip gravity', BW / 2, BH / 2 + 155);
  ctx.fillText('Cyan gates \u2192 stay on ceiling', BW / 2, BH / 2 + 173);
  ctx.fillText('Magenta gates \u2192 stay on floor', BW / 2, BH / 2 + 191);
  ctx.fillText('Collect stars to fill Flux Meter', BW / 2, BH / 2 + 209);

  // Decorative demo ship
  drawShipAt(BW / 2, BH / 2 - 145, true, 1.3);
}

function renderGame() {
  // Particles behind everything
  renderParticles();

  // Stars
  for (const s of stars) {
    if (s.collected) continue;
    ctx.save();
    ctx.translate(s.x, s.y);
    const rot = performance.now() / 600;
    ctx.rotate(rot);
    drawStarShape(0, 0, s.r, s.r * 0.45, 5);
    ctx.fillStyle = '#ffd700';
    ctx.fill();
    ctx.restore();
    // Glow
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r + 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,215,0,0.25)'; ctx.fill();
    ctx.restore();
  }

  // Hazards
  for (const h of hazards) {
    if (h.type === 'block') {
      const bHue = h.lane === 'floor' ? 0 : 240;
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(h.x - h.w / 2 + 3, h.y - h.h / 2 + 3, h.w, h.h);
      // Block
      ctx.fillStyle = `hsl(${bHue},55%,32%)`;
      ctx.fillRect(h.x - h.w / 2, h.y - h.h / 2, h.w, h.h);
      ctx.strokeStyle = `hsl(${bHue},75%,50%)`;
      ctx.lineWidth = 2;
      ctx.strokeRect(h.x - h.w / 2, h.y - h.h / 2, h.w, h.h);
      // Inner cross pattern
      ctx.strokeStyle = `hsla(${bHue},80%,55%,0.25)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(h.x - h.w / 2, h.y - h.h / 2);
      ctx.lineTo(h.x + h.w / 2, h.y + h.h / 2);
      ctx.moveTo(h.x + h.w / 2, h.y - h.h / 2);
      ctx.lineTo(h.x - h.w / 2, h.y + h.h / 2);
      ctx.stroke();
    } else if (h.type === 'gate') {
      const isCyan = h.color === 'cyan';
      const gc = isCyan ? [0, 255, 255] : [255, 0, 255];
      const gcStr = `${gc[0]},${gc[1]},${gc[2]}`;

      // Field background
      ctx.fillStyle = `rgba(${gcStr},0.06)`;
      ctx.fillRect(h.x, CEIL_Y, h.w, PLAY_H);

      // Animated energy lines
      const t = performance.now() / 200;
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.strokeStyle = `rgb(${gcStr})`;
      ctx.lineWidth = 1;
      for (let ly = CEIL_Y; ly < FLOOR_Y; ly += 20) {
        const waveX = Math.sin((ly + t * 30) * 0.05) * 3;
        ctx.beginPath();
        ctx.moveTo(h.x + waveX, ly);
        ctx.lineTo(h.x + h.w + waveX, ly);
        ctx.stroke();
      }
      ctx.restore();

      // Main gate field
      ctx.fillStyle = `rgba(${gcStr},0.18)`;
      ctx.fillRect(h.x, CEIL_Y, h.w, PLAY_H);

      // Gate edges
      ctx.strokeStyle = `rgba(${gcStr},0.7)`;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(h.x, CEIL_Y); ctx.lineTo(h.x, FLOOR_Y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(h.x + h.w, CEIL_Y); ctx.lineTo(h.x + h.w, FLOOR_Y); ctx.stroke();

      // Safe lane indicator arrow
      const safeY = h.safeLane === 'floor' ? FLOOR_Y - 25 : CEIL_Y + 25;
      const unsafeY = h.safeLane === 'floor' ? CEIL_Y + 25 : FLOOR_Y - 25;
      ctx.fillStyle = `rgba(${gcStr},0.8)`;
      ctx.font = "bold 18px 'Segoe UI',system-ui,sans-serif";
      ctx.textAlign = 'center';
      ctx.fillText(h.safeLane === 'floor' ? '\u25BC' : '\u25B2', h.x + h.w / 2, safeY);
      // Danger X on unsafe side
      ctx.fillStyle = 'rgba(255,60,60,0.5)';
      ctx.font = "bold 16px 'Segoe UI',system-ui,sans-serif";
      ctx.fillText('\u2716', h.x + h.w / 2, unsafeY);
    }
  }

  // Player
  drawShipAt(PLAYER_X, playerY, onFloor, 1);

  // HUD
  renderHUD();

  // Float texts
  for (const t of texts) {
    const a = clamp(t.life / t.maxLife, 0, 1);
    ctx.globalAlpha = a;
    ctx.fillStyle = t.color;
    ctx.font = `bold ${t.size}px 'Segoe UI',system-ui,sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(t.txt, t.x, t.y);
  }
  ctx.globalAlpha = 1;

  // Game over overlay
  if (state === 'gameover') {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, BW, BH);

    ctx.fillStyle = '#fff';
    ctx.font = "bold 38px 'Segoe UI',system-ui,sans-serif";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GAME OVER', BW / 2, BH / 2 - 70);

    ctx.font = "24px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText('Score: ' + Math.floor(score), BW / 2, BH / 2 - 15);

    const isNew = Math.floor(score) >= bestScore && Math.floor(score) > 0;
    ctx.fillStyle = isNew ? '#ffd700' : 'rgba(255,255,255,0.55)';
    ctx.font = "16px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText('Best: ' + bestScore, BW / 2, BH / 2 + 20);

    if (isNew) {
      ctx.fillStyle = '#ffd700';
      ctx.font = "bold 18px 'Segoe UI',system-ui,sans-serif";
      ctx.fillText('\u2605 NEW BEST!', BW / 2, BH / 2 + 52);
    }

    const p2 = 0.4 + 0.5 * Math.sin(performance.now() / 350);
    ctx.fillStyle = `rgba(255,255,255,${p2})`;
    ctx.font = "20px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText('Tap to Retry', BW / 2, BH / 2 + 100);
  }
}

function drawShipAt(x, y, isFloor, sc) {
  ctx.save();
  ctx.translate(x, y);
  if (sc !== 1) ctx.scale(sc, sc);

  // Glow
  const gCol = isFloor ? 'rgba(0,255,255,0.12)' : 'rgba(255,0,255,0.12)';
  ctx.beginPath(); ctx.arc(0, 0, PLAYER_R + 12, 0, Math.PI * 2);
  ctx.fillStyle = gCol; ctx.fill();

  // Ship body - arrow shape
  const dir = isFloor ? 1 : -1;
  ctx.beginPath();
  ctx.moveTo(PLAYER_R + 3, 0);
  ctx.lineTo(-PLAYER_R + 2, dir * -PLAYER_R * 0.85);
  ctx.lineTo(-PLAYER_R * 0.35, 0);
  ctx.lineTo(-PLAYER_R + 2, dir * PLAYER_R * 0.85);
  ctx.closePath();

  const sg = ctx.createLinearGradient(-PLAYER_R, 0, PLAYER_R, 0);
  if (isFloor) {
    sg.addColorStop(0, '#006688');
    sg.addColorStop(1, '#00ddff');
  } else {
    sg.addColorStop(0, '#660066');
    sg.addColorStop(1, '#ee00ee');
  }
  ctx.fillStyle = sg;
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Cockpit
  ctx.beginPath(); ctx.arc(2, 0, 3.5, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.fill();

  ctx.restore();
}

function drawStarShape(cx, cy, outerR, innerR, points) {
  ctx.beginPath();
  for (let i = 0; i < points * 2; i++) {
    const r = i % 2 === 0 ? outerR : innerR;
    const a = Math.PI * i / points - Math.PI / 2;
    const x = cx + Math.cos(a) * r;
    const y = cy + Math.sin(a) * r;
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.closePath();
}

function renderParticles() {
  for (const p of particles) {
    const a = clamp(p.life / p.maxLife, 0, 1);
    if (p.type === 'ring') {
      ctx.strokeStyle = `rgba(255,255,255,${a * 0.5})`;
      ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.stroke();
      continue;
    }
    ctx.globalAlpha = a;
    ctx.fillStyle = `hsla(${p.hue},${p.sat}%,${p.light}%,${a})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r * (0.3 + 0.7 * a), 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function renderHUD() {
  // Score
  ctx.fillStyle = '#fff';
  ctx.font = "bold 26px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(Math.floor(score), 16, 12);

  // Combo
  if (comboMult > 1) {
    ctx.fillStyle = '#0f0';
    ctx.font = "bold 13px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText('x' + comboMult.toFixed(1) + ' (' + combo + ')', 16, 42);
  }

  // Flux meter
  const fmX = BW - 115, fmY = 14, fmW = 100, fmH = 14;
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  roundRect(ctx, fmX, fmY, fmW, fmH, 3);
  ctx.fill();

  const fluxPct = fluxMeter / FLUX_MAX;
  if (fluxPct > 0) {
    const fg = ctx.createLinearGradient(fmX, 0, fmX + fmW, 0);
    fg.addColorStop(0, '#00ffff');
    fg.addColorStop(1, '#ff00ff');
    ctx.fillStyle = fg;
    roundRect(ctx, fmX, fmY, fmW * fluxPct, fmH, 3);
    ctx.fill();
  }

  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  roundRect(ctx, fmX, fmY, fmW, fmH, 3);
  ctx.stroke();

  // Label
  ctx.fillStyle = bulletTime ? '#0ff' : 'rgba(255,255,255,0.4)';
  ctx.font = "bold 10px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign = 'right';
  ctx.fillText(bulletTime ? 'FLUX!' : 'FLUX', fmX - 5, fmY + 11);

  // Bullet time indicator
  if (bulletTime) {
    const bp = 0.5 + 0.5 * Math.sin(performance.now() / 150);
    ctx.fillStyle = `rgba(0,255,255,${0.3 + bp * 0.4})`;
    ctx.font = "bold 14px 'Segoe UI',system-ui,sans-serif";
    ctx.textAlign = 'center';
    ctx.fillText('BULLET TIME', BW / 2, 38);
  }
}

function roundRect(c, x, y, w, h, r) {
  c.beginPath();
  c.moveTo(x + r, y); c.lineTo(x + w - r, y);
  c.quadraticCurveTo(x + w, y, x + w, y + r);
  c.lineTo(x + w, y + h - r);
  c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  c.lineTo(x + r, y + h);
  c.quadraticCurveTo(x, y + h, x, y + h - r);
  c.lineTo(x, y + r);
  c.quadraticCurveTo(x, y, x + r, y);
  c.closePath();
}

// ── Game Loop ────────────────────────────────────────────────
let lastTime = 0;

function loop(now) {
  requestAnimationFrame(loop);
  if (!lastTime) lastTime = now;
  let rawDt = (now - lastTime) / 1000;
  lastTime = now;
  rawDt = Math.min(rawDt, 0.05);

  update(rawDt);

  // Keep particles / texts alive during gameover
  if (state === 'gameover') {
    updateParticles(rawDt, rawDt);
    for (let i = texts.length - 1; i >= 0; i--) {
      texts[i].life -= rawDt;
      if (texts[i].life <= 0) texts.splice(i, 1);
      else texts[i].y += texts[i].vy * rawDt;
    }
    if (shakeDur > 0) {
      shakeDur -= rawDt;
      const t = clamp(shakeDur / 0.45, 0, 1);
      shakeX = Math.sin(performance.now() * 0.05) * shakeIntensity * t;
      shakeY = Math.cos(performance.now() * 0.07) * shakeIntensity * t;
      if (shakeDur <= 0) { shakeX = 0; shakeY = 0; }
    }
  }

  render();
}

// ── Boot ─────────────────────────────────────────────────────
initGame();
particles = []; texts = []; hazards = []; stars = [];
gridOffset = 0;
requestAnimationFrame(loop);

})();
</script>
</body>
</html>