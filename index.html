<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<link rel="canonical" href="https://balinti.github.io/gravity-flip/">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip - Free HTML5 Game">
<meta name="twitter:description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="twitter:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:system-ui,-apple-system,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;width:100%;height:100%;height:100dvh}
#game-container{flex:1;display:flex;justify-content:center;align-items:center;width:100%;max-width:420px;max-height:750px}
canvas{display:block;width:100%;height:100%;image-rendering:auto}
#info{color:#555;font-size:11px;text-align:center;padding:6px 12px;max-width:420px;line-height:1.4}
#info h2{font-size:13px;color:#666;margin-bottom:3px}
</style>
</head>
<body>
<div id="wrap">
<div id="game-container"><canvas id="c"></canvas></div>
<div id="info">
<h2>How to Play Gravity Flip</h2>
<p>You are a polarity orb auto-running through a tunnel with two rails (ceiling and floor). Tap or press Space/Enter to flip between rails instantly. Dodge gates that are safe on one rail but lethal on the other. Collect Burst Orbs to build your score multiplier (x1 to x4). Every flip adds Heat &mdash; overheat and your flip is briefly locked! Score comes from distance, multiplier bonuses, and smooth running with fewer flips. Difficulty increases over time with faster speed and trickier patterns.</p>
</div>
</div>
<script>
'use strict';
(()=>{
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const W=420,H=750;
const LS_KEY='gravityFlip_highScore_v1';

/* --- High-DPI scaling --- */
function resize(){
  const dpr=Math.min(window.devicePixelRatio||1,3);
  const cont=document.getElementById('game-container');
  const rect=cont.getBoundingClientRect();
  canvas.width=Math.round(rect.width*dpr);
  canvas.height=Math.round(rect.height*dpr);
  canvas.style.width=rect.width+'px';
  canvas.style.height=rect.height+'px';
  ctx.setTransform(dpr*rect.width/W,0,0,dpr*rect.height/H,0,0);
}
window.addEventListener('resize',resize);
resize();

/* --- Constants --- */
const RAIL_TOP=90;
const RAIL_BOT=H-90;
const RAIL_MID=(RAIL_TOP+RAIL_BOT)/2;
const PX=85;
const PR=14;
const TUNNEL_PAD=30;
const HEAT_MAX=100;
const HEAT_PER_FLIP=22;
const HEAT_DRAIN=12;
const HEAT_LOCK_DUR=0.65;
const FLIP_EASE_DUR=0.08;
const DEATH_FREEZE=0.08;
const CHAIN_DECAY_ON_FLIP=0.15;
const SMOOTH_BONUS_INTERVAL=4.0;

/* --- State --- */
let state='start';
let time=0,score=0,scoreF=0,best=parseInt(localStorage.getItem(LS_KEY))||0;
let rail=1; // 0=top, 1=bot
let playerY=RAIL_BOT,targetY=RAIL_BOT;
let flipEaseT=0;
let heat=0,heatLocked=0;
let chainProgress=0,multiplier=1;
let lastFlipTime=-10,flipCount=0;
let smoothTimer=0;
let obstacles=[],burstOrbs=[],particles=[];
let spawnDist=0,nextSpawnDist=0;
let totalDist=0;
let shake=0;
let deathFreeze=0,deathFlash=0;
let lastTime=0;
let bgStars=[];

/* --- Challenge mode --- */
const params=new URLSearchParams(window.location.search);
const challengeScore=params.has('challenge')?parseInt(params.get('challenge'),10):null;

/* --- Background stars --- */
for(let i=0;i<60;i++) bgStars.push({x:Math.random()*W,y:Math.random()*H,s:0.5+Math.random()*1.5,b:0.2+Math.random()*0.5});

/* --- Helpers --- */
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function easeOutQuad(t){return 1-(1-t)*(1-t)}

/* --- Difficulty curve --- */
function diff(){return 1-Math.exp(-time/35)}
function speed(){return 220+180*diff()}
function minReactDist(){return Math.max(130,200-50*diff())}
function spawnInterval(){return minReactDist()+40+Math.random()*80}

/* --- Chunk-based obstacle spawner --- */
function spawnObstacle(){
  const d=diff();
  const r=Math.random();
  let type;
  if(r<0.12+0.18*d) type='split';
  else type='gate';

  const obs={x:W+40,type,passed:false,w:30};

  if(type==='gate'){
    // safe on one rail, lethal on other
    obs.safeRail=Math.random()<0.5?0:1;
    obs.gapH=clamp(110-30*d,60,110);
  }else{
    // split wall: small gap on each rail, player must pick
    obs.gapH=clamp(70-15*d,45,70);
  }
  obstacles.push(obs);

  // Burst orb chance
  if(Math.random()<0.38){
    const orbRail=Math.random()<0.5?0:1;
    const oy=orbRail===0?RAIL_TOP:RAIL_BOT;
    burstOrbs.push({x:obs.x+60+Math.random()*40,y:oy+(Math.random()-0.5)*20,r:11,alive:true,pulse:Math.random()*Math.PI*2});
  }
}

/* --- Particles --- */
function addP(x,y,count,hue,spd,life,sMin,sMax){
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2;
    const s=spd*(0.3+Math.random()*0.7);
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:life*(0.5+Math.random()*0.5),maxLife:life,hue,size:sMin+Math.random()*(sMax-sMin)});
  }
}

function addRingP(x,y,count,hue,radius,life){
  for(let i=0;i<count;i++){
    const a=(i/count)*Math.PI*2;
    particles.push({x:x+Math.cos(a)*radius,y:y+Math.sin(a)*radius,vx:Math.cos(a)*60,vy:Math.sin(a)*60,life,maxLife:life,hue,size:2+Math.random()*2});
  }
}

/* --- Reset --- */
function resetGame(){
  time=0;score=0;scoreF=0;
  rail=1;playerY=RAIL_BOT;targetY=RAIL_BOT;flipEaseT=0;
  heat=0;heatLocked=0;
  chainProgress=0;multiplier=1;
  lastFlipTime=-10;flipCount=0;smoothTimer=0;
  obstacles=[];burstOrbs=[];particles=[];
  spawnDist=0;nextSpawnDist=spawnInterval();
  totalDist=0;shake=0;deathFreeze=0;deathFlash=0;
}

/* --- Input --- */
function doFlip(){
  if(state==='start'){state='playing';resetGame();return;}
  if(state==='gameover'){state='start';return;}
  if(state!=='playing')return;
  if(heatLocked>0)return;

  // Flip rail
  rail=rail===0?1:0;
  targetY=rail===0?RAIL_TOP:RAIL_BOT;
  flipEaseT=0;

  // Heat
  heat=Math.min(HEAT_MAX,heat+HEAT_PER_FLIP);
  if(heat>=HEAT_MAX){
    heatLocked=HEAT_LOCK_DUR;
    shake=Math.max(shake,6);
    addP(PX,playerY,15,0,200,0.5,2,5);
  }

  // Chain decay on flip
  chainProgress=Math.max(0,chainProgress-CHAIN_DECAY_ON_FLIP);
  updateMultiplier();

  flipCount++;
  lastFlipTime=time;

  // Flip burst particles
  const h=baseHue();
  addP(PX,playerY,10,(h+90)%360,250,0.35,2,5);
  shake=Math.max(shake,1.5);
}

canvas.addEventListener('pointerdown',e=>{e.preventDefault();doFlip();});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();doFlip();}
});

/* --- Multiplier --- */
function updateMultiplier(){
  if(chainProgress>=3)multiplier=4;
  else if(chainProgress>=2)multiplier=3;
  else if(chainProgress>=1)multiplier=2;
  else multiplier=1;
}

/* --- Collision detection --- */
function hitObstacle(obs){
  const r=PR;
  if(PX+r<obs.x||PX-r>obs.x+obs.w)return false;

  if(obs.type==='gate'){
    // Gate: wall covers the lethal rail zone, gap on safe rail
    const safeCenter=obs.safeRail===0?RAIL_TOP:RAIL_BOT;
    const gapTop=safeCenter-obs.gapH/2;
    const gapBot=safeCenter+obs.gapH/2;
    // Player safe if inside gap
    if(playerY-r>=gapTop&&playerY+r<=gapBot)return false;
    return true;
  }

  if(obs.type==='split'){
    // Two gaps, one at each rail
    const topCenter=RAIL_TOP;
    const botCenter=RAIL_BOT;
    const inTop=playerY-r>=topCenter-obs.gapH/2&&playerY+r<=topCenter+obs.gapH/2;
    const inBot=playerY-r>=botCenter-obs.gapH/2&&playerY+r<=botCenter+obs.gapH/2;
    return!(inTop||inBot);
  }
  return false;
}

/* --- Simulation step --- */
function simStep(dt){
  if(deathFreeze>0){deathFreeze-=dt;return;}

  time+=dt;
  const spd=speed();
  totalDist+=spd*dt;

  // Player easing
  if(flipEaseT<FLIP_EASE_DUR){
    flipEaseT+=dt;
    const t=clamp(flipEaseT/FLIP_EASE_DUR,0,1);
    playerY=lerp(playerY,targetY,easeOutQuad(t));
  }else{
    playerY=targetY;
  }

  // Heat drain
  if(heatLocked>0){
    heatLocked-=dt;
    if(heatLocked<=0){heatLocked=0;heat=HEAT_MAX*0.3;}
  }else{
    heat=Math.max(0,heat-HEAT_DRAIN*dt);
  }

  // Smooth-run bonus (reward fewer flips)
  smoothTimer+=dt;
  if(smoothTimer>=SMOOTH_BONUS_INTERVAL){
    smoothTimer-=SMOOTH_BONUS_INTERVAL;
    scoreF+=0.5*multiplier;
    score=Math.floor(scoreF);
  }

  // Distance score
  scoreF+=spd*dt*0.008*multiplier;
  score=Math.floor(scoreF);

  // Spawn obstacles
  spawnDist+=spd*dt;
  if(spawnDist>=nextSpawnDist){
    spawnObstacle();
    spawnDist=0;
    nextSpawnDist=spawnInterval();
  }

  // Update obstacles
  for(let i=obstacles.length-1;i>=0;i--){
    const o=obstacles[i];
    o.x-=spd*dt;
    if(!o.passed&&o.x+o.w<PX){
      o.passed=true;
      scoreF+=1*multiplier;
      score=Math.floor(scoreF);
      // Subtle pass shake at high speed
      if(spd>340) shake=Math.max(shake,0.8);
    }
    if(o.x+o.w<-20){obstacles.splice(i,1);continue;}
    if(!o.passed&&hitObstacle(o)){die();return;}
  }

  // Update burst orbs
  for(let i=burstOrbs.length-1;i>=0;i--){
    const o=burstOrbs[i];
    o.x-=spd*dt;
    o.pulse+=dt*6;
    if(o.alive&&Math.hypot(PX-o.x,playerY-o.y)<PR+o.r+5){
      o.alive=false;
      chainProgress=Math.min(3,chainProgress+1);
      updateMultiplier();
      scoreF+=2*multiplier;
      score=Math.floor(scoreF);
      // Pickup effects
      addRingP(o.x,o.y,16,(baseHue()+60)%360,20,0.4);
      addP(o.x,o.y,12,50,300,0.45,2,5);
      shake=Math.max(shake,2.5);
    }
    if(!o.alive&&o.x<-20){burstOrbs.splice(i,1);continue;}
    if(o.x<-20){
      // Missed orb: break chain
      if(o.alive){chainProgress=0;updateMultiplier();}
      burstOrbs.splice(i,1);
    }
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*dt;p.y+=p.vy*dt;
    p.vy+=200*dt; // slight gravity on particles
    p.life-=dt;
    if(p.life<=0)particles.splice(i,1);
  }

  // Shake decay
  shake=Math.max(0,shake-18*dt);
}

/* --- Death --- */
function die(){
  deathFreeze=DEATH_FREEZE;
  deathFlash=0.35;
  shake=20;
  addP(PX,playerY,50,0,600,1.0,3,12);
  addP(PX,playerY,25,30,400,0.8,2,8);
  if(score>best){best=score;localStorage.setItem(LS_KEY,best);}
  // Small delay then gameover
  setTimeout(()=>{state='gameover';},DEATH_FREEZE*1000+30);
}

/* --- Drawing --- */
function baseHue(){return(time*14+score*3)%360}

function drawBg(){
  const h=baseHue();
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,`hsl(${h},35%,6%)`);
  grad.addColorStop(0.5,`hsl(${(h+25)%360},30%,10%)`);
  grad.addColorStop(1,`hsl(${(h+50)%360},35%,6%)`);
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,W,H);

  // Stars
  for(const s of bgStars){
    const flicker=s.b+0.2*Math.sin(time*2+s.x);
    ctx.fillStyle=`rgba(255,255,255,${flicker})`;
    ctx.fillRect(s.x,s.y,s.s,s.s);
  }

  // Tunnel walls
  ctx.fillStyle=`hsla(${h},40%,20%,0.3)`;
  ctx.fillRect(0,0,W,RAIL_TOP-TUNNEL_PAD);
  ctx.fillRect(0,RAIL_BOT+TUNNEL_PAD,W,H-(RAIL_BOT+TUNNEL_PAD));

  // Rail lines
  ctx.strokeStyle=`hsla(${h},50%,35%,0.25)`;
  ctx.lineWidth=1;
  ctx.setLineDash([6,10]);
  ctx.beginPath();ctx.moveTo(0,RAIL_TOP);ctx.lineTo(W,RAIL_TOP);ctx.stroke();
  ctx.beginPath();ctx.moveTo(0,RAIL_BOT);ctx.lineTo(W,RAIL_BOT);ctx.stroke();
  ctx.setLineDash([]);

  // Center line
  ctx.strokeStyle=`hsla(${h},30%,25%,0.12)`;
  ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,RAIL_MID);ctx.lineTo(W,RAIL_MID);ctx.stroke();
}

function drawObstacles(){
  const h=baseHue();
  for(const o of obstacles){
    const proximity=1-clamp(Math.abs(o.x-PX)/180,0,1);
    const alpha=0.5+0.5*proximity;

    if(o.type==='gate'){
      const safeCenter=o.safeRail===0?RAIL_TOP:RAIL_BOT;
      const gapTop=safeCenter-o.gapH/2;
      const gapBot=safeCenter+o.gapH/2;
      const dangerHue=(h+180)%360;
      const safeHue=(h+90)%360;

      // Draw solid walls (lethal parts)
      ctx.fillStyle=`hsla(${dangerHue},70%,45%,${alpha})`;
      ctx.shadowColor=proximity>0.2?`hsla(${dangerHue},80%,55%,${proximity*0.4})`:'transparent';
      ctx.shadowBlur=proximity>0.2?10*proximity:0;

      // Wall above gap
      if(gapTop>RAIL_TOP-TUNNEL_PAD){
        ctx.fillRect(o.x,RAIL_TOP-TUNNEL_PAD,o.w,gapTop-(RAIL_TOP-TUNNEL_PAD));
      }
      // Wall below gap
      if(gapBot<RAIL_BOT+TUNNEL_PAD){
        ctx.fillRect(o.x,gapBot,o.w,(RAIL_BOT+TUNNEL_PAD)-gapBot);
      }
      ctx.shadowBlur=0;

      // Safe indicator glow on gap edges
      ctx.fillStyle=`hsla(${safeHue},70%,55%,${alpha*0.5})`;
      ctx.fillRect(o.x-2,gapTop,o.w+4,3);
      ctx.fillRect(o.x-2,gapBot-3,o.w+4,3);

    }else if(o.type==='split'){
      const hue2=(h+150)%360;
      ctx.fillStyle=`hsla(${hue2},65%,45%,${alpha})`;
      ctx.shadowColor=proximity>0.2?`hsla(${hue2},70%,55%,${proximity*0.4})`:'transparent';
      ctx.shadowBlur=proximity>0.2?10*proximity:0;

      const topGapTop=RAIL_TOP-o.gapH/2;
      const topGapBot=RAIL_TOP+o.gapH/2;
      const botGapTop=RAIL_BOT-o.gapH/2;
      const botGapBot=RAIL_BOT+o.gapH/2;

      // Wall: top of tunnel to top gap
      ctx.fillRect(o.x,RAIL_TOP-TUNNEL_PAD,o.w,topGapTop-(RAIL_TOP-TUNNEL_PAD));
      // Wall: between top gap and bottom gap
      ctx.fillRect(o.x,topGapBot,o.w,botGapTop-topGapBot);
      // Wall: bottom gap to bottom of tunnel
      ctx.fillRect(o.x,botGapBot,o.w,(RAIL_BOT+TUNNEL_PAD)-botGapBot);
      ctx.shadowBlur=0;
    }
  }
}

function drawBurstOrbs(){
  const h=baseHue();
  for(const o of burstOrbs){
    if(!o.alive)continue;
    const pulse=1+0.12*Math.sin(o.pulse);
    const orbHue=(h+60)%360;

    // Outer glow
    ctx.beginPath();
    ctx.arc(o.x,o.y,o.r*pulse+6,0,Math.PI*2);
    ctx.fillStyle=`hsla(${orbHue},80%,60%,0.15)`;
    ctx.fill();

    // Core
    ctx.beginPath();
    ctx.arc(o.x,o.y,o.r*pulse,0,Math.PI*2);
    const og=ctx.createRadialGradient(o.x-2,o.y-2,2,o.x,o.y,o.r*pulse);
    og.addColorStop(0,`hsla(${orbHue},90%,85%,0.95)`);
    og.addColorStop(1,`hsla(${orbHue},85%,55%,0.9)`);
    ctx.fillStyle=og;
    ctx.shadowColor=`hsla(${orbHue},90%,65%,0.7)`;
    ctx.shadowBlur=16;
    ctx.fill();
    ctx.shadowBlur=0;

    // Inner sparkle
    const sparkle=0.5+0.5*Math.sin(o.pulse*3);
    ctx.beginPath();
    ctx.arc(o.x,o.y,o.r*0.4*sparkle,0,Math.PI*2);
    ctx.fillStyle=`rgba(255,255,255,${sparkle*0.8})`;
    ctx.fill();
  }
}

function drawPlayer(){
  const h=baseHue();

  // Trail
  const trailAlpha=clamp((speed()-220)/200,0,0.5);
  if(trailAlpha>0.02){
    ctx.beginPath();
    ctx.moveTo(PX-30,playerY);
    ctx.lineTo(PX-PR,playerY-PR*0.6);
    ctx.lineTo(PX-PR,playerY+PR*0.6);
    ctx.closePath();
    ctx.fillStyle=`hsla(${h},70%,55%,${trailAlpha})`;
    ctx.fill();
  }

  // Outer glow
  ctx.beginPath();
  ctx.arc(PX,playerY,PR+6,0,Math.PI*2);
  ctx.fillStyle=`hsla(${h},80%,60%,0.2)`;
  ctx.fill();

  // Core orb
  ctx.beginPath();
  ctx.arc(PX,playerY,PR,0,Math.PI*2);
  const pg=ctx.createRadialGradient(PX-3,playerY-3,2,PX,playerY,PR);
  pg.addColorStop(0,`hsla(${h},90%,85%,1)`);
  pg.addColorStop(1,`hsla(${h},80%,55%,1)`);
  ctx.fillStyle=pg;
  ctx.shadowColor=`hsla(${h},90%,60%,0.8)`;
  ctx.shadowBlur=22;
  ctx.fill();
  ctx.shadowBlur=0;

  // Heat lock visual
  if(heatLocked>0){
    const lockPulse=0.5+0.5*Math.sin(time*20);
    ctx.beginPath();
    ctx.arc(PX,playerY,PR+12+4*lockPulse,0,Math.PI*2);
    ctx.strokeStyle=`hsla(0,80%,50%,${0.4+0.3*lockPulse})`;
    ctx.lineWidth=3;
    ctx.stroke();
  }

  // Flip ring
  if(time-lastFlipTime<0.25){
    const t=(time-lastFlipTime)/0.25;
    ctx.beginPath();
    ctx.arc(PX,playerY,PR+8+15*t,0,Math.PI*2);
    ctx.strokeStyle=`hsla(${(h+90)%360},85%,65%,${(1-t)*0.6})`;
    ctx.lineWidth=2;
    ctx.stroke();
  }
}

function drawParticles(){
  for(const p of particles){
    const a=clamp(p.life/p.maxLife,0,1);
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.size*a,0,Math.PI*2);
    ctx.fillStyle=`hsla(${p.hue},80%,60%,${a*0.8})`;
    ctx.fill();
  }
}

function drawHeatVignette(){
  if(heat<50)return;
  const intensity=(heat-50)/50;
  const grad=ctx.createRadialGradient(W/2,H/2,H*0.3,W/2,H/2,H*0.7);
  grad.addColorStop(0,'rgba(0,0,0,0)');
  grad.addColorStop(1,`rgba(200,50,0,${intensity*0.18})`);
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,W,H);

  // Ember particles when hot
  if(heat>75&&Math.random()<0.3){
    particles.push({x:Math.random()*W,y:H,vx:(Math.random()-0.5)*40,vy:-100-Math.random()*100,life:0.6,maxLife:0.6,hue:15+Math.random()*20,size:1+Math.random()*2});
  }
}

function drawHUD(){
  const h=baseHue();

  // Score
  ctx.textAlign='left';
  ctx.font='bold 24px system-ui,sans-serif';
  ctx.fillStyle=`hsla(${h},60%,85%,0.9)`;
  ctx.fillText(`${score}`,16,38);

  // Multiplier
  if(multiplier>1){
    ctx.font='bold 15px system-ui,sans-serif';
    ctx.fillStyle=`hsla(50,90%,65%,${0.6+0.4*Math.sin(time*8)})`;
    ctx.fillText(`x${multiplier}`,16,58);
  }

  // Heat bar (top right, safe zone)
  const barW=70,barH=8,barX=W-16-barW,barY=16;
  ctx.fillStyle='rgba(255,255,255,0.1)';
  roundRect(ctx,barX,barY,barW,barH,4);ctx.fill();
  const heatFrac=heat/HEAT_MAX;
  const heatColor=heatFrac>0.7?`hsla(0,80%,55%,0.85)`:`hsla(40,70%,50%,0.6)`;
  if(heatFrac>0){
    ctx.fillStyle=heatColor;
    roundRect(ctx,barX,barY,barW*heatFrac,barH,4);ctx.fill();
  }
  if(heatLocked>0){
    ctx.font='bold 10px system-ui,sans-serif';
    ctx.textAlign='right';
    ctx.fillStyle=`hsla(0,80%,60%,${0.5+0.5*Math.sin(time*15)})`;
    ctx.fillText('LOCKED',barX-6,barY+8);
  }else{
    ctx.font='9px system-ui,sans-serif';
    ctx.textAlign='right';
    ctx.fillStyle='rgba(255,255,255,0.3)';
    ctx.fillText('HEAT',barX-6,barY+7);
  }

  // Chain progress dots
  ctx.textAlign='center';
  const dotY=barY+24;
  for(let i=0;i<3;i++){
    const dx=barX+barW-12-i*16;
    ctx.beginPath();
    ctx.arc(dx,dotY,4,0,Math.PI*2);
    if(chainProgress>i){
      ctx.fillStyle=`hsla(50,85%,60%,0.9)`;
    }else{
      ctx.fillStyle='rgba(255,255,255,0.15)';
    }
    ctx.fill();
  }
}

function roundRect(c,x,y,w,h,r){
  c.beginPath();
  c.moveTo(x+r,y);c.lineTo(x+w-r,y);c.quadraticCurveTo(x+w,y,x+w,y+r);
  c.lineTo(x+w,y+h-r);c.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  c.lineTo(x+r,y+h);c.quadraticCurveTo(x,y+h,x,y+h-r);
  c.lineTo(x,y+r);c.quadraticCurveTo(x,y,x+r,y);
  c.closePath();
}

function drawStartScreen(){
  const h=baseHue();
  drawBg();

  // Ambient particles
  if(Math.random()<0.08) addP(Math.random()*W,Math.random()*H,1,(h+Math.random()*120)%360,40,1.5,1,3);
  drawParticles();

  ctx.textAlign='center';

  // Title
  ctx.font='bold 44px system-ui,sans-serif';
  ctx.fillStyle=`hsla(${h},80%,75%,1)`;
  ctx.shadowColor=`hsla(${h},90%,60%,0.6)`;
  ctx.shadowBlur=25;
  ctx.fillText('GRAVITY',W/2,H/2-90);
  ctx.font='bold 52px system-ui,sans-serif';
  ctx.fillStyle=`hsla(${(h+40)%360},80%,75%,1)`;
  ctx.fillText('FLIP',W/2,H/2-35);
  ctx.shadowBlur=0;

  // Subtitle
  ctx.font='14px system-ui,sans-serif';
  ctx.fillStyle=`hsla(${h},40%,65%,0.6)`;
  ctx.fillText('Polar Rail Runner',W/2,H/2-5);

  // Tap to start
  const blink=0.4+0.6*Math.sin(time*4);
  ctx.font='18px system-ui,sans-serif';
  ctx.fillStyle=`rgba(255,255,255,${blink})`;
  ctx.fillText('Tap to Start',W/2,H/2+50);

  ctx.font='12px system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.35)';
  ctx.fillText('Space / Enter / Tap',W/2,H/2+75);

  if(best>0){
    ctx.font='15px system-ui,sans-serif';
    ctx.fillStyle=`hsla(${h},55%,70%,0.7)`;
    ctx.fillText(`Best: ${best}`,W/2,H/2+115);
  }

  if(challengeScore!==null){
    ctx.font='bold 18px system-ui,sans-serif';
    ctx.fillStyle=`hsla(50,90%,65%,${blink})`;
    ctx.fillText(`Beat ${challengeScore}!`,W/2,H/2+150);
  }

  // Rail hint
  ctx.font='11px system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.2)';
  ctx.fillText('flip between ceiling & floor rails',W/2,H/2+200);
}

function drawGameOver(){
  const h=baseHue();
  drawBg();drawObstacles();drawBurstOrbs();drawParticles();drawPlayer();

  if(deathFlash>0){
    ctx.fillStyle=`rgba(255,255,255,${deathFlash})`;
    ctx.fillRect(0,0,W,H);
  }

  // Overlay
  ctx.fillStyle='rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,W,H);

  ctx.textAlign='center';
  ctx.font='bold 34px system-ui,sans-serif';
  ctx.fillStyle=`hsla(${h},70%,70%,1)`;
  ctx.fillText('GAME OVER',W/2,H/2-90);

  ctx.font='bold 52px system-ui,sans-serif';
  ctx.fillStyle='#fff';
  ctx.fillText(`${score}`,W/2,H/2-30);

  ctx.font='16px system-ui,sans-serif';
  ctx.fillStyle=`hsla(${h},50%,70%,0.8)`;
  ctx.fillText(`Best: ${best}`,W/2,H/2+5);

  if(challengeScore!==null){
    ctx.font='bold 16px system-ui,sans-serif';
    if(score>=challengeScore){
      ctx.fillStyle='hsla(120,80%,60%,1)';
      ctx.fillText('Challenge Beaten!',W/2,H/2+35);
    }else{
      ctx.fillStyle='hsla(0,70%,60%,0.9)';
      ctx.fillText(`Needed ${challengeScore}`,W/2,H/2+35);
    }
  }

  const blink=0.4+0.6*Math.sin(time*4);
  ctx.font='18px system-ui,sans-serif';
  ctx.fillStyle=`rgba(255,255,255,${blink})`;
  ctx.fillText('Tap to Retry',W/2,H/2+75);

  // Share button
  const sbw=110,sbh=34,sbx=W/2-sbw/2,sby=H/2+100;
  roundRect(ctx,sbx,sby,sbw,sbh,8);
  ctx.fillStyle='rgba(255,255,255,0.1)';
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.2)';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.font='bold 14px system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.7)';
  ctx.fillText('Share',W/2,sby+22);

  // Store share button bounds for click detection
  drawGameOver._shareBtn={x:sbx,y:sby,w:sbw,h:sbh};
}
drawGameOver._shareBtn=null;

/* --- Share --- */
function getShareText(){return`I scored ${score} in Gravity Flip! Can you beat me?`}
function getShareUrl(){return`https://balinti.github.io/gravity-flip/?challenge=${score}`}

function handleShareClick(mx,my){
  if(state!=='gameover'||!drawGameOver._shareBtn)return false;
  const b=drawGameOver._shareBtn;
  if(mx>=b.x&&mx<=b.x+b.w&&my>=b.y&&my<=b.y+b.h){
    if(navigator.share){
      navigator.share({title:'Gravity Flip',text:getShareText(),url:getShareUrl()}).catch(()=>{});
    }else{
      navigator.clipboard.writeText(getShareText()+' '+getShareUrl()).then(()=>{}).catch(()=>{});
    }
    return true;
  }
  return false;
}

// Override pointerdown for share detection
canvas.removeEventListener('pointerdown',doFlip);
canvas.addEventListener('pointerdown',e=>{
  e.preventDefault();
  const rect=canvas.getBoundingClientRect();
  const mx=(e.clientX-rect.left)*(W/rect.width);
  const my=(e.clientY-rect.top)*(H/rect.height);
  if(handleShareClick(mx,my))return;
  doFlip();
});

/* --- Main loop --- */
function frame(ts){
  requestAnimationFrame(frame);
  if(!lastTime){lastTime=ts;return;}
  let dt=(ts-lastTime)/1000;
  lastTime=ts;
  if(dt>0.04)dt=0.04; // clamp

  if(state==='playing'){
    simStep(dt);
  }else{
    time+=dt;
    // Animate particles in menu
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.x+=p.vx*dt;p.y+=p.vy*dt;
      p.life-=dt;
      if(p.life<=0)particles.splice(i,1);
    }
    if(deathFlash>0)deathFlash=Math.max(0,deathFlash-dt*2);
    shake=Math.max(0,shake-18*dt);
  }

  // Draw
  ctx.save();
  if(shake>0.1){
    ctx.translate((Math.random()-0.5)*shake*2,(Math.random()-0.5)*shake*2);
  }

  if(state==='start') drawStartScreen();
  else if(state==='playing'){
    drawBg();drawObstacles();drawBurstOrbs();drawPlayer();drawParticles();drawHeatVignette();drawHUD();
  }else drawGameOver();

  ctx.restore();
}
requestAnimationFrame(frame);
})();
</script>
</body>
</html>