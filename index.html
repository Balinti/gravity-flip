<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<link rel="canonical" href="https://balinti.github.io/gravity-flip/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#05050f;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#e0e0e0;touch-action:none;user-select:none;-webkit-user-select:none}
#game-wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;min-height:100dvh}
#game-container{position:relative;width:100%;max-width:420px;max-height:750px;aspect-ratio:420/750;background:#0a0a1a;border-radius:8px;overflow:hidden;box-shadow:0 0 40px rgba(100,60,255,.15)}
canvas{display:block;width:100%;height:100%}
#hud{position:absolute;top:0;left:0;right:0;display:flex;justify-content:space-between;align-items:flex-start;padding:12px 16px;pointer-events:none;z-index:2}
#hud-left,#hud-right{display:flex;flex-direction:column;gap:2px}
#hud-left{align-items:flex-start}
#hud-right{align-items:flex-end}
.hud-label{font-size:10px;text-transform:uppercase;letter-spacing:1.5px;opacity:.5}
.hud-value{font-size:22px;font-weight:700;letter-spacing:1px;text-shadow:0 0 10px rgba(255,255,255,.3)}
#combo-display{font-size:14px;font-weight:700;letter-spacing:1px;transition:opacity .2s}
#polarity-indicator{display:flex;align-items:center;gap:6px;margin-top:4px}
#polarity-dot{width:12px;height:12px;border-radius:50%;border:2px solid rgba(255,255,255,.3);transition:background .15s}
#polarity-text{font-size:11px;font-weight:600;letter-spacing:1px;text-transform:uppercase}
#seo-section{max-width:420px;width:100%;padding:16px 12px;text-align:center;margin-top:8px}
#seo-section h1{font-size:14px;font-weight:600;color:#888;margin-bottom:4px}
#seo-section p{font-size:11px;color:#555;line-height:1.5}
</style>
</head>
<body>
<div id="game-wrap">
<div id="game-container">
<canvas id="c"></canvas>
<div id="hud">
<div id="hud-left">
<span class="hud-label">Score</span>
<span class="hud-value" id="score-display">0</span>
<div id="combo-display" style="opacity:0">x1</div>
</div>
<div id="hud-right">
<span class="hud-label">Best</span>
<span class="hud-value" id="best-display">0</span>
<div id="polarity-indicator">
<div id="polarity-dot"></div>
<span id="polarity-text">LIGHT</span>
</div>
</div>
</div>
</div>
<div id="seo-section">
<h1>Gravity Flip - Free Browser Game</h1>
<p>Tap or press Space to flip between ceiling and floor. Match the right polarity to pass through gates. Collect combo sparks to boost your multiplier. How far can you go?</p>
</div>
</div>

<script>
'use strict';
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');
const scoreEl = document.getElementById('score-display');
const bestEl = document.getElementById('best-display');
const comboEl = document.getElementById('combo-display');
const polarityDot = document.getElementById('polarity-dot');
const polarityText = document.getElementById('polarity-text');

// --- Constants ---
const W = 420, H = 750;
const WALL_T = 18;
const PLAYER_R = 14;
const FLOOR_Y = H - WALL_T - PLAYER_R - 2;
const CEIL_Y = WALL_T + PLAYER_R + 2;
const PLAYER_X = 80;
const FLIP_DURATION = 0.12;
const GRAZE_DIST = 8;

const LIGHT_COL = '#f0e6ff';
const DARK_COL = '#1a0a30';
const LIGHT_GATE = 'rgba(240,230,255,0.85)';
const DARK_GATE = 'rgba(26,10,48,0.85)';
const SPIKE_COL = '#ff3366';
const SPARK_COL = '#ffdd44';

// --- State ---
let state = 'start';
let dpr = 1;
let score = 0;
let bestScore = parseInt(localStorage.getItem('gf_best')) || 0;
let bestCombo = parseInt(localStorage.getItem('gf_bestcombo')) || 0;
let combo = 1;
let comboTimer = 0;
const COMBO_DECAY_TIME = 2.5;
let polarity = 0; // 0=light, 1=dark
let playerY = FLOOR_Y;
let targetY = FLOOR_Y;
let flipT = 0;
let flipFrom = FLOOR_Y;
let isFlipping = false;
let onFloor = true;
let gameSpeed = 1;
let baseSpeed = 3.2;
let distanceTraveled = 0;
let difficultyLevel = 0;

let obstacles = [];
let sparksList = [];
let particles = [];
let bgParticles = [];
let shakeX = 0, shakeY = 0, shakeMag = 0, shakeDecay = 0;
let hitStopTimer = 0;
let comboHue = 220;
let lastTime = 0;
let frameCount = 0;

// --- Resize ---
function resize() {
    const rect = container.getBoundingClientRect();
    dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr * rect.width / W, 0, 0, dpr * rect.height / H, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// --- Utility ---
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function rnd(a, b) { return a + Math.random() * (b - a); }
function rndInt(a, b) { return Math.floor(rnd(a, b + 1)); }
function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

function hsl(h, s, l, a) {
    if (a !== undefined) return `hsla(${h|0},${s|0}%,${l|0}%,${a})`;
    return `hsl(${h|0},${s|0}%,${l|0}%)`;
}

// --- Particles ---
function spawnFlipBurst(x, y, pol) {
    const col = pol === 0 ? LIGHT_COL : '#6030cc';
    for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 / 12) * i + rnd(-0.2, 0.2);
        const spd = rnd(1.5, 4);
        particles.push({
            x, y,
            vx: Math.cos(angle) * spd,
            vy: Math.sin(angle) * spd,
            life: 1, decay: rnd(1.5, 2.5),
            r: rnd(2, 4),
            col
        });
    }
}

function spawnGatePing(x, y, w, h, pol) {
    const col = pol === 0 ? '#aa88ff' : '#ffaa44';
    for (let i = 0; i < 8; i++) {
        particles.push({
            x: x + rnd(0, w), y: y + rnd(0, h),
            vx: rnd(-2, 2), vy: rnd(-2, 2),
            life: 1, decay: rnd(1.8, 2.8),
            r: rnd(2, 5),
            col
        });
    }
    // Ripple
    particles.push({
        x: x + w / 2, y: y + h / 2,
        vx: 0, vy: 0,
        life: 1, decay: 1.2,
        r: 5, maxR: 50,
        col, isRipple: true
    });
}

function spawnDeathShatter(x, y) {
    for (let i = 0; i < 30; i++) {
        const angle = rnd(0, Math.PI * 2);
        const spd = rnd(2, 8);
        particles.push({
            x, y,
            vx: Math.cos(angle) * spd,
            vy: Math.sin(angle) * spd,
            life: 1, decay: rnd(0.6, 1.5),
            r: rnd(2, 6),
            col: [SPIKE_COL, '#ff6699', '#ffaacc', '#ffffff'][rndInt(0, 3)]
        });
    }
}

function spawnSparkCollect(x, y) {
    for (let i = 0; i < 6; i++) {
        const angle = rnd(0, Math.PI * 2);
        const spd = rnd(1, 3);
        particles.push({
            x, y,
            vx: Math.cos(angle) * spd,
            vy: Math.sin(angle) * spd,
            life: 1, decay: rnd(1.5, 2.5),
            r: rnd(2, 4),
            col: SPARK_COL
        });
    }
}

// --- Background particles ---
function initBgParticles() {
    bgParticles = [];
    for (let i = 0; i < 30; i++) {
        bgParticles.push({
            x: rnd(0, W), y: rnd(0, H),
            r: rnd(0.5, 2),
            speed: rnd(0.2, 0.8),
            alpha: rnd(0.05, 0.2)
        });
    }
}
initBgParticles();

// --- Obstacle Spawning ---
function getMinGap() {
    return Math.max(160, 280 - difficultyLevel * 10);
}

function getObstacleSpeed() {
    return baseSpeed * gameSpeed;
}

let lastSpawnX = W + 200;

function spawnObstacle() {
    const spd = getObstacleSpeed();
    const minGap = getMinGap();

    // Check buffer distance from last obstacle
    if (obstacles.length > 0) {
        let maxX = 0;
        for (const o of obstacles) {
            if (o.x + o.w > maxX) maxX = o.x + o.w;
        }
        for (const s of sparksList) {
            if (s.x + s.r > maxX) maxX = s.x + s.r;
        }
        if (maxX + minGap > W + 10) return;
    }

    const roll = Math.random();
    const dl = difficultyLevel;

    if (roll < 0.30) {
        // Single spike
        const onF = Math.random() < 0.5;
        obstacles.push({
            type: 'spike',
            x: W + 20,
            y: onF ? H - WALL_T - 30 : WALL_T,
            w: 22, h: 30,
            onFloor: onF,
            speed: spd,
            grazed: false
        });
    } else if (roll < 0.45 && dl >= 2) {
        // Staggered dual spikes (floor then ceiling, offset to be solvable)
        obstacles.push({
            type: 'spike', x: W + 20,
            y: H - WALL_T - 30, w: 22, h: 30,
            onFloor: true, speed: spd, grazed: false
        });
        // Offset the ceiling spike so player has time to flip
        const offset = Math.max(80, 140 - dl * 5);
        obstacles.push({
            type: 'spike', x: W + 20 + offset,
            y: WALL_T, w: 22, h: 30,
            onFloor: false, speed: spd, grazed: false
        });
    } else if (roll < 0.75) {
        // Gate (polarity-locked)
        const gPol = Math.random() < 0.5 ? 0 : 1;
        const onF = Math.random() < 0.5;
        const gH = 55;
        const gY = onF ? H - WALL_T - gH : WALL_T;
        obstacles.push({
            type: 'gate',
            x: W + 20,
            y: gY,
            w: 30, h: gH,
            polarity: gPol,
            onFloor: onF,
            speed: spd,
            scored: false
        });
    } else {
        // Combo Spark collectible
        const sy = rnd(CEIL_Y + 30, FLOOR_Y - 30);
        sparksList.push({
            x: W + 20, y: sy,
            r: 8,
            speed: spd,
            alive: true,
            pulse: 0
        });
    }
}

// --- Collision ---
function circleAABB(cx, cy, cr, rx, ry, rw, rh) {
    const nearX = clamp(cx, rx, rx + rw);
    const nearY = clamp(cy, ry, ry + rh);
    const dx = cx - nearX;
    const dy = cy - nearY;
    return dx * dx + dy * dy < cr * cr;
}

// --- Game Logic ---
function resetGame() {
    state = 'playing';
    score = 0;
    combo = 1;
    comboTimer = COMBO_DECAY_TIME;
    polarity = 0;
    playerY = FLOOR_Y;
    targetY = FLOOR_Y;
    flipT = 0;
    isFlipping = false;
    onFloor = true;
    gameSpeed = 1;
    distanceTraveled = 0;
    difficultyLevel = 0;
    obstacles = [];
    sparksList = [];
    particles = [];
    shakeMag = 0;
    hitStopTimer = 0;
    comboHue = 220;
    spawnCd = 0.5;
    updateHUD();
}

function doFlip() {
    if (isFlipping) return;
    onFloor = !onFloor;
    polarity = 1 - polarity;
    targetY = onFloor ? FLOOR_Y : CEIL_Y;
    flipFrom = playerY;
    flipT = 0;
    isFlipping = true;
    spawnFlipBurst(PLAYER_X, playerY, polarity);
}

function addScore(pts) {
    score += Math.round(pts * combo);
    comboTimer = COMBO_DECAY_TIME;
    updateHUD();
}

function boostCombo() {
    combo = Math.min(combo + 0.5, 10);
    comboTimer = COMBO_DECAY_TIME;
    updateHUD();
}

function triggerGraze() {
    hitStopTimer = 0.04;
    shakeMag = 3;
    shakeDecay = 8;
    addScore(5);
    boostCombo();
}

function die() {
    state = 'gameover';
    spawnDeathShatter(PLAYER_X, playerY);
    shakeMag = 12;
    shakeDecay = 3;
    if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('gf_best', bestScore);
    }
    if (combo > bestCombo) {
        bestCombo = Math.floor(combo);
        localStorage.setItem('gf_bestcombo', bestCombo);
    }
    updateHUD();
}

function updateHUD() {
    scoreEl.textContent = score;
    bestEl.textContent = bestScore;
    if (combo > 1) {
        comboEl.style.opacity = '1';
        comboEl.textContent = 'x' + combo.toFixed(1);
        comboEl.style.color = hsl(comboHue, 80, 65);
    } else {
        comboEl.style.opacity = '0';
    }
    const pol = polarity === 0;
    polarityDot.style.background = pol ? LIGHT_COL : '#6030cc';
    polarityText.textContent = pol ? 'LIGHT' : 'DARK';
    polarityText.style.color = pol ? LIGHT_COL : '#a070ff';
}

// --- Spawn timer ---
let spawnCd = 0;

function update(dt) {
    if (hitStopTimer > 0) {
        hitStopTimer -= dt;
        return;
    }

    frameCount++;
    distanceTraveled += getObstacleSpeed() * dt * 60;
    difficultyLevel = Math.floor(distanceTraveled / 2000);
    gameSpeed = 1 + difficultyLevel * 0.06;

    // Flip animation
    if (isFlipping) {
        flipT += dt / FLIP_DURATION;
        if (flipT >= 1) {
            flipT = 1;
            isFlipping = false;
        }
        playerY = lerp(flipFrom, targetY, easeInOutCubic(flipT));
    }

    // Combo decay
    comboTimer -= dt;
    if (comboTimer <= 0) {
        combo = Math.max(1, combo - dt * 1.5);
        if (combo <= 1) combo = 1;
        updateHUD();
    }

    // Combo hue shift
    comboHue = 220 + (combo - 1) * 15;

    // Spawn
    spawnCd -= dt;
    if (spawnCd <= 0) {
        spawnObstacle();
        spawnCd = rnd(0.35, 0.8) / gameSpeed;
    }

    // Distance score (1 point per ~6 frames)
    if (frameCount % 6 === 0) addScore(1);

    // Update obstacles
    const spd = getObstacleSpeed();
    let grazed = false;
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= spd * dt * 60;
        if (o.x + o.w < -30) {
            obstacles.splice(i, 1);
            continue;
        }
        // Collision
        if (o.type === 'spike') {
            if (circleAABB(PLAYER_X, playerY, PLAYER_R - 2, o.x, o.y, o.w, o.h)) {
                die(); return;
            }
            // Graze detection
            if (!grazed && !o.grazed && circleAABB(PLAYER_X, playerY, PLAYER_R + GRAZE_DIST, o.x, o.y, o.w, o.h)) {
                o.grazed = true;
                triggerGraze();
                grazed = true;
            }
        } else if (o.type === 'gate') {
            if (circleAABB(PLAYER_X, playerY, PLAYER_R - 2, o.x, o.y, o.w, o.h)) {
                if (polarity === o.polarity) {
                    die(); return;
                } else if (!o.scored) {
                    o.scored = true;
                    addScore(15);
                    boostCombo();
                    spawnGatePing(o.x, o.y, o.w, o.h, o.polarity);
                }
            }
        }
    }

    // Update sparks
    for (let i = sparksList.length - 1; i >= 0; i--) {
        const s = sparksList[i];
        s.x -= spd * dt * 60;
        s.pulse += dt * 4;
        if (s.x < -20) {
            sparksList.splice(i, 1);
            continue;
        }
        if (s.alive) {
            const dx = PLAYER_X - s.x;
            const dy = playerY - s.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < PLAYER_R + s.r) {
                s.alive = false;
                addScore(10);
                boostCombo();
                spawnSparkCollect(s.x, s.y);
                sparksList.splice(i, 1);
            }
        }
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= p.decay * dt;
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.96;
        p.vy *= 0.96;
        if (p.isRipple) {
            p.r = lerp(5, p.maxR, 1 - p.life);
        }
    }

    // Update bg particles
    for (const bp of bgParticles) {
        bp.x -= bp.speed * gameSpeed;
        if (bp.x < -5) { bp.x = W + 5; bp.y = rnd(0, H); }
    }

    // Screen shake decay
    if (shakeMag > 0) {
        shakeMag *= Math.pow(0.5, dt * shakeDecay);
        shakeX = rnd(-shakeMag, shakeMag);
        shakeY = rnd(-shakeMag, shakeMag);
        if (shakeMag < 0.3) { shakeMag = 0; shakeX = 0; shakeY = 0; }
    }
}

// --- Draw ---
function draw() {
    ctx.save();
    ctx.translate(shakeX, shakeY);

    // Background with combo hue shift
    const bgHue = lerp(220, comboHue, clamp((combo - 1) / 6, 0, 1));
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, hsl(bgHue, 30, 6));
    grad.addColorStop(0.5, hsl(bgHue + 10, 25, 4));
    grad.addColorStop(1, hsl(bgHue + 20, 35, 8));
    ctx.fillStyle = grad;
    ctx.fillRect(-20, -20, W + 40, H + 40);

    // Bg particles (stars)
    for (const bp of bgParticles) {
        ctx.globalAlpha = bp.alpha;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(bp.x, bp.y, bp.r, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Walls
    const wallGrad = ctx.createLinearGradient(0, 0, W, 0);
    wallGrad.addColorStop(0, hsl(bgHue + 30, 40, 20));
    wallGrad.addColorStop(1, hsl(bgHue + 50, 50, 25));
    ctx.fillStyle = wallGrad;
    ctx.fillRect(0, 0, W, WALL_T);
    ctx.fillRect(0, H - WALL_T, W, WALL_T);

    // Wall accent lines
    ctx.strokeStyle = hsl(bgHue + 40, 60, 40, 0.4);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, WALL_T); ctx.lineTo(W, WALL_T);
    ctx.moveTo(0, H - WALL_T); ctx.lineTo(W, H - WALL_T);
    ctx.stroke();

    // Obstacles
    for (const o of obstacles) {
        if (o.type === 'spike') {
            drawSpike(o);
        } else if (o.type === 'gate') {
            drawGate(o);
        }
    }

    // Sparks
    for (const s of sparksList) {
        if (!s.alive) continue;
        const pr = s.r + Math.sin(s.pulse) * 2;
        ctx.save();
        ctx.shadowColor = SPARK_COL;
        ctx.shadowBlur = 12;
        ctx.fillStyle = SPARK_COL;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
            const a2 = a + Math.PI / 5;
            const ox = s.x + Math.cos(a) * pr;
            const oy = s.y + Math.sin(a) * pr;
            const ix = s.x + Math.cos(a2) * pr * 0.45;
            const iy = s.y + Math.sin(a2) * pr * 0.45;
            if (i === 0) ctx.moveTo(ox, oy);
            else ctx.lineTo(ox, oy);
            ctx.lineTo(ix, iy);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    // Player
    drawPlayer();

    // Particles
    for (const p of particles) {
        if (p.isRipple) {
            ctx.strokeStyle = p.col;
            ctx.globalAlpha = p.life * 0.5;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        } else {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.col;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // Overlays
    if (state === 'start') drawStartScreen();
    else if (state === 'gameover') drawGameOver();

    ctx.restore();
}

function drawSpike(o) {
    ctx.fillStyle = SPIKE_COL;
    ctx.save();
    ctx.shadowColor = SPIKE_COL;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    if (o.onFloor) {
        ctx.moveTo(o.x, o.y + o.h);
        ctx.lineTo(o.x + o.w / 2, o.y);
        ctx.lineTo(o.x + o.w, o.y + o.h);
    } else {
        ctx.moveTo(o.x, o.y);
        ctx.lineTo(o.x + o.w / 2, o.y + o.h);
        ctx.lineTo(o.x + o.w, o.y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawGate(o) {
    const isLight = o.polarity === 0;
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = isLight ? LIGHT_GATE : DARK_GATE;
    ctx.strokeStyle = isLight ? '#d0c0ff' : '#4020aa';
    ctx.lineWidth = 2;
    const r = 4;
    ctx.beginPath();
    ctx.moveTo(o.x + r, o.y);
    ctx.lineTo(o.x + o.w - r, o.y);
    ctx.quadraticCurveTo(o.x + o.w, o.y, o.x + o.w, o.y + r);
    ctx.lineTo(o.x + o.w, o.y + o.h - r);
    ctx.quadraticCurveTo(o.x + o.w, o.y + o.h, o.x + o.w - r, o.y + o.h);
    ctx.lineTo(o.x + r, o.y + o.h);
    ctx.quadraticCurveTo(o.x, o.y + o.h, o.x, o.y + o.h - r);
    ctx.lineTo(o.x, o.y + r);
    ctx.quadraticCurveTo(o.x, o.y, o.x + r, o.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Polarity symbol
    ctx.globalAlpha = 1;
    ctx.fillStyle = isLight ? '#8060cc' : '#aa88ff';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(isLight ? 'L' : 'D', o.x + o.w / 2, o.y + o.h / 2);
    ctx.restore();
}

function drawPlayer() {
    ctx.save();
    const pol = polarity === 0;
    const mainCol = pol ? LIGHT_COL : '#7040dd';
    const glowCol = pol ? 'rgba(240,230,255,0.3)' : 'rgba(112,64,221,0.3)';

    // Glow
    ctx.shadowColor = mainCol;
    ctx.shadowBlur = 18;

    // Outer ring
    ctx.strokeStyle = mainCol;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(PLAYER_X, playerY, PLAYER_R, 0, Math.PI * 2);
    ctx.stroke();

    // Fill
    ctx.fillStyle = glowCol;
    ctx.beginPath();
    ctx.arc(PLAYER_X, playerY, PLAYER_R - 1, 0, Math.PI * 2);
    ctx.fill();

    // Inner dot
    ctx.fillStyle = mainCol;
    ctx.beginPath();
    ctx.arc(PLAYER_X, playerY, 4, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

function drawStartScreen() {
    ctx.fillStyle = 'rgba(5,5,15,0.65)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GRAVITY FLIP', W / 2, H / 2 - 60);

    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText('Flip between floor & ceiling', W / 2, H / 2 - 20);
    ctx.fillText('Match opposite polarity to pass gates', W / 2, H / 2 + 5);

    const pulse = 0.6 + Math.sin(Date.now() * 0.004) * 0.4;
    ctx.globalAlpha = pulse;
    ctx.font = 'bold 18px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText('TAP TO START', W / 2, H / 2 + 70);
    ctx.globalAlpha = 1;

    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#666';
    ctx.fillText('Space / Enter / Tap', W / 2, H / 2 + 100);

    if (bestScore > 0) {
        ctx.fillStyle = '#888';
        ctx.fillText('Best: ' + bestScore, W / 2, H / 2 + 140);
    }
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(5,5,15,0.7)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = SPIKE_COL;
    ctx.font = 'bold 30px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GAME OVER', W / 2, H / 2 - 70);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px sans-serif';
    ctx.fillText(score, W / 2, H / 2 - 20);

    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText('SCORE', W / 2, H / 2 + 10);

    ctx.fillStyle = '#ffdd44';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText('Best: ' + bestScore, W / 2, H / 2 + 50);

    if (bestCombo > 1) {
        ctx.fillStyle = '#aaa';
        ctx.font = '13px sans-serif';
        ctx.fillText('Best Combo: x' + bestCombo, W / 2, H / 2 + 78);
    }

    const pulse = 0.6 + Math.sin(Date.now() * 0.004) * 0.4;
    ctx.globalAlpha = pulse;
    ctx.font = 'bold 18px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText('TAP TO RETRY', W / 2, H / 2 + 120);
    ctx.globalAlpha = 1;
}

// --- Main Loop ---
function loop(now) {
    requestAnimationFrame(loop);
    if (!lastTime) { lastTime = now; return; }
    let dt = (now - lastTime) / 1000;
    lastTime = now;
    dt = Math.min(dt, 0.05);

    if (state === 'playing') {
        update(dt);
    }

    draw();
}
requestAnimationFrame(loop);

// --- Input ---
let inputBlocked = false;
function handleInput() {
    if (inputBlocked) return;
    if (state === 'start') {
        resetGame();
    } else if (state === 'playing') {
        doFlip();
    } else if (state === 'gameover') {
        inputBlocked = true;
        setTimeout(() => { inputBlocked = false; }, 300);
        resetGame();
    }
}

canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    handleInput();
});

document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'Enter') {
        e.preventDefault();
        handleInput();
    }
});

// Prevent double-tap zoom on mobile
canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });

// Initial HUD
updateHUD();
bestEl.textContent = bestScore;
</script>
</body>
</html>
