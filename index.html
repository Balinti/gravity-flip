<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<link rel="canonical" href="https://balinti.github.io/gravity-flip/">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip - Free HTML5 Game">
<meta name="twitter:description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="twitter:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:system-ui,-apple-system,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;justify-content:center;align-items:center;width:100%;height:100%;height:100dvh}
canvas{display:block;max-width:420px;max-height:750px;width:100%;height:100%;image-rendering:auto}
#seo{position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden}
#share-modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:100;justify-content:center;align-items:center}
#share-modal.open{display:flex}
#share-box{background:#1a1a2e;border-radius:12px;padding:24px;max-width:300px;width:90%;text-align:center;color:#fff}
#share-box h3{margin-bottom:16px;font-size:18px}
.share-btn{display:block;width:100%;padding:12px;margin:8px 0;border:none;border-radius:8px;font-size:15px;cursor:pointer;font-weight:600}
.share-twitter{background:#1da1f2;color:#fff}
.share-whatsapp{background:#25d366;color:#fff}
.share-copy{background:#444;color:#fff}
.share-close{background:transparent;color:#aaa;font-size:13px;margin-top:8px}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<div id="share-modal"><div id="share-box">
<h3>Share Your Score</h3>
<button class="share-btn share-twitter" id="btn-twitter">Share on Twitter</button>
<button class="share-btn share-whatsapp" id="btn-whatsapp">Share on WhatsApp</button>
<button class="share-btn share-copy" id="btn-copy">Copy Link</button>
<button class="share-btn share-close" id="btn-close">Close</button>
</div></div>
<div id="seo">
<h1>Gravity Flip - Free HTML5 Game</h1>
<p>Gravity Flip is a hyper-casual HTML5 canvas game. Tap or press Space to trigger a gravity pulse that temporarily flips your gravity direction. Navigate through gates with shifting gaps, collect overcharge orbs for bonus points and combos, and try to survive as obstacles speed up over time. Features include moving gates, split gates, overdrive mode, close-call bonuses, and increasing difficulty. Play free in your browser on desktop or mobile. Controls: Tap screen, press Space or Enter to flip gravity.</p>
</div>
<script>
'use strict';
(()=>{
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const W=420,H=750;
const dtFixed=1/120;
const LS_KEY='GP_highScore';

function resize(){
const dpr=Math.min(window.devicePixelRatio||1,3);
const rect=canvas.getBoundingClientRect();
canvas.width=W*dpr;
canvas.height=H*dpr;
ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',resize);
resize();

const params=new URLSearchParams(window.location.search);
const challengeScore=params.has('challenge')?parseInt(params.get('challenge'),10):null;

let state='start';
let time=0,score=0,scoreFloat=0,best=parseInt(localStorage.getItem(LS_KEY))||0;
let homeG=1;
let py,vy,pulseTimer=0;
let gates=[],orbs=[],particles=[];
let spawnTimer=0;
let shake=0;
let heat=0,overdrive=0,mult=1,combo=0;
let accumulator=0;
let lastTime=0;
let deathFlash=0;
let shareBtn=null;
let shareBtnGameover=null;

const PX=90,PR=12;
const G0=2200;
const MAX_VY=1400;

function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}

function resetGame(){
time=0;score=0;scoreFloat=0;
homeG=1;py=H/2;vy=0;pulseTimer=0;
gates=[];orbs=[];particles=[];
spawnTimer=0;shake=0;heat=0;overdrive=0;mult=1;combo=0;
deathFlash=0;accumulator=0;
}

function diff(){return 1-Math.exp(-time/28)}
function speed(){let s=260+160*diff();if(overdrive>0)s*=1.18;return s}
function gapHVal(){let g=Math.max(150,230-70*diff());if(overdrive>0)g*=0.88;return g}
function spawnEvery(){return Math.max(0.85,1.25-0.35*diff())}
function pulseDur(){return Math.max(0.28,0.35-0.05*diff())}

function gateType(){
const d=diff();
const pM=clamp(0.10+0.35*d,0,0.45);
const pS=clamp(0.00+0.30*Math.max(0,d-0.55)/0.45,0,0.30);
const r=Math.random();
if(r<pS)return'split';
if(r<pS+pM)return'moving';
return'standard';
}

function spawnGate(){
const type=gateType();
const gap=gapHVal();
const gapY=gap/2+30+Math.random()*(H-gap-60);
const g={x:W+30,type,gapY,gap,passed:false,w:28,closeCalled:false};
if(type==='moving'){g.ampli=40+Math.random()*50;g.freq=1.2+Math.random()*1.5;g.phase=Math.random()*Math.PI*2;g.baseY=gapY;}
if(type==='split'){
const splitGap=gap*0.38;
const mid=H/2;
g.gap1Y=mid-gap*0.28;
g.gap1H=splitGap;
g.gap2Y=mid+gap*0.28;
g.gap2H=splitGap;
}
gates.push(g);
if(Math.random()<0.35){
const oy=type==='split'?H/2:gapY;
orbs.push({x:g.x+50,y:oy+(-30+Math.random()*60),r:10,alive:true});
}
}

function addP(x,y,count,hue,spread,life,sMin,sMax){
for(let i=0;i<count;i++){
const a=Math.random()*Math.PI*2;
const sp=spread*(0.3+Math.random()*0.7);
particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:life*(0.6+Math.random()*0.4),maxLife:life,hue,size:sMin+Math.random()*(sMax-sMin)});
}
}

function triggerPulse(){
if(document.getElementById('share-modal').classList.contains('open'))return;
if(state==='start'){state='playing';resetGame();return;}
if(state==='gameover'){state='start';return;}
if(pulseTimer>0)return;
pulseTimer=pulseDur();
vy+=(-homeG)*120;
addP(PX,py,8,(time*40)%360,180,0.4,2,5);
shake=Math.max(shake,1);
}

function canvasPointerHandler(e){
if(document.getElementById('share-modal').classList.contains('open'))return;
const rect=canvas.getBoundingClientRect();
const scaleX=W/rect.width;
const scaleY=H/rect.height;
const mx=(e.clientX-rect.left)*scaleX;
const my=(e.clientY-rect.top)*scaleY;
const btn=state==='gameover'?shareBtnGameover:shareBtn;
if(btn&&(state==='gameover'||state==='start')){
if(mx>=btn.x&&mx<=btn.x+btn.w&&my>=btn.y&&my<=btn.y+btn.h){
e.preventDefault();
e.stopImmediatePropagation();
if(navigator.share){
navigator.share({title:'Gravity Flip',text:getShareText(),url:getShareUrl()}).catch(()=>{});
}else{
openShareModal();
}
return;
}
}
triggerPulse();
}
canvas.addEventListener('pointerdown',canvasPointerHandler);
document.addEventListener('keydown',e=>{
if(e.code==='Space'||e.code==='Enter'){e.preventDefault();triggerPulse();}
});

function getGateGapY(g){
return g.type==='moving'?g.baseY+Math.sin(time*g.freq+g.phase)*g.ampli:g.gapY;
}

function hitGate(g){
const r=PR;
if(PX+r<g.x||PX-r>g.x+g.w)return false;
if(g.type==='split'){
const in1=py-r>=g.gap1Y-g.gap1H/2&&py+r<=g.gap1Y+g.gap1H/2;
const in2=py-r>=g.gap2Y-g.gap2H/2&&py+r<=g.gap2Y+g.gap2H/2;
return!(in1||in2);
}
const gy=getGateGapY(g);
const top=gy-g.gap/2;
const bot=gy+g.gap/2;
return py-r<top||py+r>bot;
}

function isCloseCall(g){
if(g.closeCalled)return false;
const r=PR;
const margin=18;
if(g.type==='split'){
const d1t=Math.abs(py-(g.gap1Y-g.gap1H/2));
const d1b=Math.abs(py-(g.gap1Y+g.gap1H/2));
const d2t=Math.abs(py-(g.gap2Y-g.gap2H/2));
const d2b=Math.abs(py-(g.gap2Y+g.gap2H/2));
return Math.min(d1t,d1b,d2t,d2b)<margin+r;
}
const gy=getGateGapY(g);
const distTop=Math.abs(py-(gy-g.gap/2));
const distBot=Math.abs(py-(gy+g.gap/2));
return Math.min(distTop,distBot)<margin+r;
}

function simStep(dt){
time+=dt;
const gSign=homeG*(pulseTimer>0?-1:1);
vy+=G0*gSign*dt;
vy*=Math.pow(0.92,dt*60);
vy=clamp(vy,-MAX_VY,MAX_VY);
py+=vy*dt;
if(py<PR){py=PR;vy=Math.abs(vy)*0.4;}
if(py>H-PR){py=H-PR;vy=-Math.abs(vy)*0.4;}
if(pulseTimer>0)pulseTimer=Math.max(0,pulseTimer-dt);
if(overdrive>0){overdrive-=dt;if(overdrive<=0){overdrive=0;mult=1;}}
heat=clamp(heat-6*dt,0,100);
spawnTimer-=dt;
if(spawnTimer<=0){spawnGate();spawnTimer=spawnEvery();}
const spd=speed();
for(let i=gates.length-1;i>=0;i--){
const g=gates[i];
g.x-=spd*dt;
if(!g.passed&&g.x+g.w<PX){
g.passed=true;
scoreFloat+=1*mult;
score=Math.floor(scoreFloat);
shake=Math.max(shake,1);
addP(PX,py,4,(time*30)%360,100,0.3,2,4);
if(isCloseCall(g)){
g.closeCalled=true;
scoreFloat+=0.2*mult;
score=Math.floor(scoreFloat);
shake=Math.max(shake,2);
addP(PX,py,10,60,200,0.5,1,3);
}
}
if(g.x+g.w<-10){gates.splice(i,1);}
else if(hitGate(g)){die();return;}
}
for(let i=orbs.length-1;i>=0;i--){
const o=orbs[i];
o.x-=spd*dt;
if(o.alive&&Math.hypot(PX-o.x,py-o.y)<PR+o.r){
o.alive=false;
scoreFloat+=1*mult;
combo++;
score=Math.floor(scoreFloat);
heat+=18;
shake=Math.max(shake,3);
addP(o.x,o.y,12,50,250,0.5,2,6);
if(heat>=100&&overdrive<=0){
overdrive=4.5;heat=40;mult=2.5;
shake=Math.max(shake,10);
addP(PX,py,30,30,400,0.8,3,8);
}
}
if(o.x<-20)orbs.splice(i,1);
}
for(let i=particles.length-1;i>=0;i--){
const p=particles[i];
p.x+=p.vx*dt;p.y+=p.vy*dt;
p.life-=dt;
if(p.life<=0)particles.splice(i,1);
}
shake=Math.max(0,shake-28*dt);
}

function die(){
state='gameover';
deathFlash=0.3;
shake=16;
addP(PX,py,40,0,500,1.0,3,10);
if(score>best){best=score;localStorage.setItem(LS_KEY,best);}
}

function baseHue(){return(time*12+score*6)%360}

function drawBg(){
const h=baseHue();
const grad=ctx.createLinearGradient(0,0,0,H);
grad.addColorStop(0,`hsl(${h},40%,8%)`);
grad.addColorStop(0.5,`hsl(${(h+30)%360},35%,12%)`);
grad.addColorStop(1,`hsl(${(h+60)%360},40%,8%)`);
ctx.fillStyle=grad;
ctx.fillRect(0,0,W,H);
ctx.strokeStyle=`hsla(${h},50%,25%,0.15)`;
ctx.lineWidth=1;
for(let y=0;y<=H;y+=30){
ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();
}
}

function drawGates(){
const h=baseHue();
for(const g of gates){
const dist=Math.max(0,1-Math.abs(g.x-PX)/200);
const alpha=0.4+0.6*dist;
if(g.type==='split'){
const hue2=(h+180)%360;
ctx.fillStyle=`hsla(${hue2},70%,50%,${alpha})`;
ctx.shadowColor=dist>0.1?`hsla(${hue2},80%,60%,${dist*0.5})`:'transparent';
ctx.shadowBlur=dist>0.1?12*dist:0;
ctx.fillRect(g.x,0,g.w,g.gap1Y-g.gap1H/2);
ctx.fillRect(g.x,g.gap1Y+g.gap1H/2,g.w,g.gap2Y-g.gap2H/2-(g.gap1Y+g.gap1H/2));
ctx.fillRect(g.x,g.gap2Y+g.gap2H/2,g.w,H-(g.gap2Y+g.gap2H/2));
ctx.shadowBlur=0;
}else{
const gy=getGateGapY(g);
const top=gy-g.gap/2;
const bot=gy+g.gap/2;
const hue2=g.type==='moving'?(h+120)%360:(h+180)%360;
ctx.fillStyle=`hsla(${hue2},70%,50%,${alpha})`;
ctx.shadowColor=dist>0.1?`hsla(${hue2},80%,60%,${dist*0.5})`:'transparent';
ctx.shadowBlur=dist>0.1?12*dist:0;
ctx.fillRect(g.x,0,g.w,top);
ctx.fillRect(g.x,bot,g.w,H-bot);
ctx.shadowBlur=0;
}
}
}

function drawOrbs(){
const h=baseHue();
for(const o of orbs){
if(!o.alive)continue;
const pulse=1+0.15*Math.sin(time*8);
ctx.beginPath();
ctx.arc(o.x,o.y,o.r*pulse,0,Math.PI*2);
ctx.fillStyle=`hsla(${(h+60)%360},90%,65%,0.9)`;
ctx.shadowColor=`hsla(${(h+60)%360},90%,70%,0.7)`;
ctx.shadowBlur=14;
ctx.fill();
ctx.shadowBlur=0;
}
}

function drawGhostArc(){
const steps=25;
const dt2=1/60;
let gx=PX,gy=py,gvy=vy;
const gSign=homeG*(pulseTimer>0?-1:1);
ctx.beginPath();
ctx.moveTo(gx,gy);
for(let i=0;i<steps;i++){
gvy+=G0*gSign*dt2;
gvy*=Math.pow(0.92,dt2*60);
gvy=clamp(gvy,-MAX_VY,MAX_VY);
gy+=gvy*dt2;
gy=clamp(gy,PR,H-PR);
gx+=speed()*dt2;
ctx.lineTo(gx,gy);
}
ctx.strokeStyle='rgba(255,255,255,0.1)';
ctx.lineWidth=2;
ctx.setLineDash([4,6]);
ctx.stroke();
ctx.setLineDash([]);
}

function drawPlayer(){
const h=baseHue();
drawGhostArc();
ctx.beginPath();
ctx.arc(PX,py,PR+4,0,Math.PI*2);
ctx.fillStyle=`hsla(${h},80%,60%,0.2)`;
ctx.fill();
ctx.beginPath();
ctx.arc(PX,py,PR,0,Math.PI*2);
const pg=ctx.createRadialGradient(PX-3,py-3,2,PX,py,PR);
pg.addColorStop(0,`hsla(${h},90%,80%,1)`);
pg.addColorStop(1,`hsla(${h},80%,55%,1)`);
ctx.fillStyle=pg;
ctx.shadowColor=`hsla(${h},90%,60%,0.8)`;
ctx.shadowBlur=20;
ctx.fill();
ctx.shadowBlur=0;
if(pulseTimer>0){
const pa=pulseTimer/pulseDur();
ctx.beginPath();
ctx.arc(PX,py,PR+10+10*(1-pa),0,Math.PI*2);
ctx.strokeStyle=`hsla(${(h+90)%360},90%,70%,${pa*0.6})`;
ctx.lineWidth=2;
ctx.stroke();
}
}

function drawParticles(){
for(const p of particles){
const a=p.life/p.maxLife;
ctx.beginPath();
ctx.arc(p.x,p.y,p.size*a,0,Math.PI*2);
ctx.fillStyle=`hsla(${p.hue},80%,60%,${a*0.8})`;
ctx.fill();
}
}

function drawOverdriveOverlay(){
if(overdrive<=0)return;
const a=Math.min(overdrive/0.5,1)*0.15;
const grad=ctx.createRadialGradient(W/2,H/2,100,W/2,H/2,W);
grad.addColorStop(0,'rgba(0,0,0,0)');
grad.addColorStop(1,`rgba(255,140,0,${a})`);
ctx.fillStyle=grad;
ctx.fillRect(0,0,W,H);
if(Math.random()<0.4){
particles.push({x:W,y:Math.random()*H,vx:-800-Math.random()*400,vy:0,life:0.3,maxLife:0.3,hue:30+Math.random()*30,size:1+Math.random()*2});
}
}

function drawHUD(){
const h=baseHue();
ctx.textAlign='left';
ctx.font='bold 22px system-ui,sans-serif';
ctx.fillStyle=`hsla(${h},60%,85%,0.9)`;
ctx.fillText(`${score}`,15,35);
if(overdrive>0){
ctx.font='bold 14px system-ui,sans-serif';
ctx.fillStyle=`hsla(30,90%,60%,${0.6+0.4*Math.sin(time*10)})`;
ctx.fillText(`OVERDRIVE x${mult.toFixed(1)}`,15,55);
}
if(combo>1){
ctx.font='bold 13px system-ui,sans-serif';
ctx.fillStyle='hsla(50,80%,70%,0.7)';
ctx.textAlign='right';
ctx.fillText(`Combo x${combo}`,W-15,35);
}
const barW=60,barH=5;
const bx=W-15-barW,by=H-20;
ctx.fillStyle='rgba(255,255,255,0.15)';
ctx.fillRect(bx,by,barW,barH);
ctx.fillStyle=heat>70?'hsla(0,80%,55%,0.8)':'hsla(40,80%,55%,0.6)';
ctx.fillRect(bx,by,barW*(heat/100),barH);
}

function roundRect(c,x,y,w,h,r){
c.beginPath();
c.moveTo(x+r,y);c.lineTo(x+w-r,y);c.quadraticCurveTo(x+w,y,x+w,y+r);
c.lineTo(x+w,y+h-r);c.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
c.lineTo(x+r,y+h);c.quadraticCurveTo(x,y+h,x,y+h-r);
c.lineTo(x,y+r);c.quadraticCurveTo(x,y,x+r,y);
c.closePath();
}

function drawShareBtn(x,y){
ctx.textAlign='center';
ctx.font='bold 14px system-ui,sans-serif';
const bw=100,bh=32;
roundRect(ctx,x-bw/2,y-bh/2,bw,bh,8);
ctx.fillStyle='rgba(255,255,255,0.12)';
ctx.fill();
ctx.fillStyle='rgba(255,255,255,0.7)';
ctx.fillText('Share',x,y+5);
return{x:x-bw/2,y:y-bh/2,w:bw,h:bh};
}

function drawStartScreen(){
const h=baseHue();
drawBg();
if(Math.random()<0.12)addP(Math.random()*W,Math.random()*H,1,(h+Math.random()*120)%360,50,1.5,1,3);
drawParticles();
ctx.textAlign='center';
ctx.font='bold 42px system-ui,sans-serif';
ctx.fillStyle=`hsla(${h},80%,75%,1)`;
ctx.shadowColor=`hsla(${h},90%,60%,0.6)`;
ctx.shadowBlur=20;
ctx.fillText('GRAVITY',W/2,H/2-80);
ctx.font='bold 48px system-ui,sans-serif';
ctx.fillStyle=`hsla(${(h+40)%360},80%,75%,1)`;
ctx.fillText('FLIP',W/2,H/2-30);
ctx.shadowBlur=0;
ctx.font='16px system-ui,sans-serif';
ctx.fillStyle=`hsla(${h},50%,70%,0.7)`;
ctx.fillText('Pulse Runner',W/2,H/2+5);
const blink=0.5+0.5*Math.sin(time*4);
ctx.font='18px system-ui,sans-serif';
ctx.fillStyle=`hsla(0,0%,90%,${blink})`;
ctx.fillText('Tap to Start',W/2,H/2+60);
ctx.font='13px system-ui,sans-serif';
ctx.fillStyle='rgba(255,255,255,0.4)';
ctx.fillText('Space / Enter / Tap',W/2,H/2+90);
if(best>0){
ctx.font='15px system-ui,sans-serif';
ctx.fillStyle=`hsla(${h},60%,70%,0.7)`;
ctx.fillText(`Best: ${best}`,W/2,H/2+130);
}
if(challengeScore!==null){
ctx.font='bold 20px system-ui,sans-serif';
ctx.fillStyle=`hsla(50,90%,65%,${blink})`;
ctx.fillText(`Beat ${challengeScore}!`,W/2,H/2+170);
}
shareBtn=drawShareBtn(W/2,H-60);
}

function drawGameOver(){
const h=baseHue();
drawBg();drawGates();drawOrbs();drawParticles();drawPlayer();
if(deathFlash>0){
ctx.fillStyle=`rgba(255,255,255,${deathFlash})`;
ctx.fillRect(0,0,W,H);
}
ctx.fillStyle='rgba(0,0,0,0.55)';
ctx.fillRect(0,0,W,H);
ctx.textAlign='center';
ctx.font='bold 36px system-ui,sans-serif';
ctx.fillStyle=`hsla(${h},70%,70%,1)`;
ctx.fillText('GAME OVER',W/2,H/2-80);
ctx.font='bold 48px system-ui,sans-serif';
ctx.fillStyle='#fff';
ctx.fillText(`${score}`,W/2,H/2-25);
ctx.font='16px system-ui,sans-serif';
ctx.fillStyle=`hsla(${h},50%,70%,0.8)`;
ctx.fillText(`Best: ${best}`,W/2,H/2+10);
if(challengeScore!==null){
ctx.font='bold 18px system-ui,sans-serif';
if(score>=challengeScore){
ctx.fillStyle='hsla(120,80%,60%,1)';
ctx.fillText('Challenge Beaten!',W/2,H/2+45);
}else{
ctx.fillStyle='hsla(0,70%,60%,1)';
ctx.fillText(`Needed ${challengeScore}`,W/2,H/2+45);
}
}
const blink=0.5+0.5*Math.sin(time*4);
ctx.font='18px system-ui,sans-serif';
ctx.fillStyle=`rgba(255,255,255,${blink})`;
ctx.fillText('Tap to Retry',W/2,H/2+85);
shareBtnGameover=drawShareBtn(W/2,H/2+130);
}

function getShareText(){return`I scored ${score} in Gravity Flip! Can you beat me?`}
function getShareUrl(){return`https://balinti.github.io/gravity-flip/?challenge=${score}`}

function openShareModal(){document.getElementById('share-modal').classList.add('open')}
function closeShareModal(){document.getElementById('share-modal').classList.remove('open')}

document.getElementById('btn-twitter').addEventListener('click',()=>{
const t=encodeURIComponent(getShareText());
const u=encodeURIComponent(getShareUrl());
window.open(`https://twitter.com/intent/tweet?text=${t}&url=${u}`,'_blank');
closeShareModal();
});
document.getElementById('btn-whatsapp').addEventListener('click',()=>{
const t=encodeURIComponent(getShareText()+' '+getShareUrl());
window.open(`https://wa.me/?text=${t}`,'_blank');
closeShareModal();
});
document.getElementById('btn-copy').addEventListener('click',()=>{
navigator.clipboard.writeText(getShareUrl()).then(()=>{
const b=document.getElementById('btn-copy');b.textContent='Copied!';
setTimeout(()=>{b.textContent='Copy Link';},1500);
}).catch(()=>{});
});
document.getElementById('btn-close').addEventListener('click',closeShareModal);
document.getElementById('share-modal').addEventListener('pointerdown',e=>{
if(e.target===document.getElementById('share-modal'))closeShareModal();
});

function frame(ts){
requestAnimationFrame(frame);
if(!lastTime){lastTime=ts;return;}
let dt=(ts-lastTime)/1000;
lastTime=ts;
if(dt>0.033)dt=0.033;

if(state==='playing'){
accumulator+=dt;
while(accumulator>=dtFixed){
simStep(dtFixed);
if(state!=='playing')break;
accumulator-=dtFixed;
}
}else{
time+=dt;
for(let i=particles.length-1;i>=0;i--){
const p=particles[i];
p.x+=p.vx*dt;p.y+=p.vy*dt;
p.life-=dt;
if(p.life<=0)particles.splice(i,1);
}
if(deathFlash>0)deathFlash=Math.max(0,deathFlash-dt*2);
}

ctx.save();
if(shake>0.1){
ctx.translate((Math.random()-0.5)*shake*2,(Math.random()-0.5)*shake*2);
}
if(state==='start')drawStartScreen();
else if(state==='playing'){
drawBg();drawGates();drawOrbs();drawPlayer();drawParticles();drawOverdriveOverlay();drawHUD();
}else drawGameOver();
ctx.restore();
}
requestAnimationFrame(frame);
})();
</script>
</body>
</html>