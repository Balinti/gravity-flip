<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity up/down while dodging obstacles. Collect combo sparks for bonus points. How far can you go?">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity up/down while dodging obstacles. Collect combo sparks for bonus points.">
<meta name="twitter:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#05050f;font-family:'Segoe UI',system-ui,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{position:relative;width:100%;max-width:420px;height:100vh;max-height:750px;margin:0 auto;display:flex;flex-direction:column;background:linear-gradient(180deg,#0a0a1a 0%,#0f0f2e 100%)}
#top-bar{height:36px;display:flex;align-items:center;justify-content:center;color:#445;font-size:11px;letter-spacing:1px;flex-shrink:0}
#canvas-wrap{flex:1;position:relative;overflow:hidden}
canvas{display:block;width:100%;height:100%}
#bot-bar{height:36px;display:flex;align-items:center;justify-content:center;color:#445;font-size:11px;letter-spacing:1px;flex-shrink:0}
</style>
</head>
<body>
<div id="wrap">
  <div id="top-bar">GRAVITY FLIP</div>
  <div id="canvas-wrap"><canvas id="c"></canvas></div>
  <div id="bot-bar">COMBO GATES</div>
</div>
<script>
'use strict';
(()=>{

/* ======== CANVAS SETUP ======== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('canvas-wrap');
let W, H, dpr;
const LS_KEY = 'gf_combo_best';

function resize() {
  const r = wrap.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  W = r.width; H = r.height;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ======== TUNING CONSTANTS ======== */
const RAIL_PAD = 0.10;          // fraction from top/bottom for rails
const ORB_R = 11;
const FLIP_SPEED = 8;           // pixels per frame-ish (scaled by dt)
const BASE_SCROLL = 2.6;
const MAX_SCROLL = 6.0;
const SPEED_RAMP = 0.00025;     // per distance unit
const GATE_W = 26;
const MIN_GATE_SPACING = 155;
const SPARK_R = 7;
const PARTICLE_CAP = 140;
const EDGE_THRESHOLD = 6;       // pixels for near-miss

/* ======== GAME STATE ======== */
let state = 'start';
let score, bestScore, displayScore;
let combo, comboMult, maxCombo;
let scrollSpeed;
let orbX, orbY, orbLane;        // lane: 0=bottom rail, 1=top rail
let orbFlipping, orbFromY, orbToY, orbFlipT;
let orbSquashX, orbSquashY;
let railTop, railBot, playH;
let gates, sparks, particles;
let dist;
let shakeX, shakeY, shakePow;
let edgeAlpha, edgeTimer;
let hue;
let lastGateType, flipLockCooldown;
let speedLevel, speedFlash;

bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0;

/* ======== GATE TYPES ======== */
const GT = { SIMPLE: 0, SPLIT: 1, PULSE: 2, FLIPLOCK: 3 };

function computeRails() {
  railTop = H * RAIL_PAD;
  railBot = H * (1 - RAIL_PAD);
  playH = railBot - railTop;
}

/* ======== RESET ======== */
function resetGame() {
  computeRails();
  score = 0; displayScore = 0;
  combo = 0; comboMult = 1; maxCombo = 0;
  scrollSpeed = BASE_SCROLL;
  orbX = W * 0.2;
  orbLane = 0; // start on bottom
  orbY = railBot;
  orbFlipping = false; orbFlipT = 0;
  orbSquashX = 1; orbSquashY = 1;
  gates = []; sparks = []; particles = [];
  dist = 0;
  shakeX = 0; shakeY = 0; shakePow = 0;
  edgeAlpha = 0; edgeTimer = 0;
  hue = 190;
  lastGateType = -1; flipLockCooldown = 0;
  speedLevel = 0; speedFlash = 0;
  seedInitialGates();
}

/* ======== GATE GENERATION ======== */
function seedInitialGates() {
  let x = W + 120;
  for (let i = 0; i < 5; i++) {
    x = spawnGateAt(x);
  }
}

function pickGateType() {
  // Weighted selection based on distance
  const pool = [GT.SIMPLE, GT.SIMPLE, GT.SIMPLE];
  if (dist > 300) pool.push(GT.SPLIT, GT.SPLIT);
  if (dist > 700) pool.push(GT.PULSE, GT.PULSE);
  if (dist > 1200 && flipLockCooldown <= 0) pool.push(GT.FLIPLOCK);

  let t = pool[Math.floor(Math.random() * pool.length)];
  // Never flip-lock back to back
  if (t === GT.FLIPLOCK && lastGateType === GT.FLIPLOCK) t = GT.SIMPLE;
  lastGateType = t;
  if (t === GT.FLIPLOCK) flipLockCooldown = 3;
  else if (flipLockCooldown > 0) flipLockCooldown--;
  return t;
}

function spawnGateAt(afterX) {
  const type = pickGateType();
  const extraSpace = Math.max(0, (scrollSpeed - BASE_SCROLL) * 18);
  const spacing = MIN_GATE_SPACING + Math.random() * 70 + extraSpace;
  const x = afterX + spacing;

  // Gap fraction (how much of playH is open)
  const gapFrac = 0.30 + Math.random() * 0.14;
  const gapPx = playH * gapFrac;

  // Decide which lane(s) are safe
  let safeLane; // 0=bot safe, 1=top safe, 2=both safe (split)
  if (type === GT.SPLIT) {
    safeLane = 2;
  } else {
    safeLane = Math.random() < 0.5 ? 0 : 1;
  }

  // Build block heights
  let topH, botH, midGap;
  if (type === GT.SPLIT) {
    // Both lanes have openings; blocks are top, middle, bottom
    const openingH = gapPx * 0.45;
    const midH = playH - openingH * 2;
    topH = 0; botH = 0;
    // Store as special split gate
    return spawnSplitGate(x, type, openingH, midH);
  }

  if (safeLane === 1) {
    // Top is safe opening, bottom is mostly blocked
    topH = playH * (0.05 + Math.random() * 0.1); // small top block
    botH = playH - gapPx - topH;
  } else {
    // Bottom safe opening
    botH = playH * (0.05 + Math.random() * 0.1);
    topH = playH - gapPx - botH;
  }
  topH = Math.max(2, topH);
  botH = Math.max(2, botH);

  const g = {
    x, type, safeLane, topH, botH,
    w: GATE_W,
    pulsePhase: Math.random() * Math.PI * 2,
    pulseAmp: type === GT.PULSE ? playH * 0.055 : 0,
    flipLockStart: type === GT.FLIPLOCK ? x - 55 - Math.random() * 30 : 0,
    scored: false, edged: false, comboChecked: false,
    split: false
  };
  gates.push(g);

  // Spark in the RISKY opening (opposite of safe lane)
  const sparkLane = 1 - safeLane;
  let sparkY;
  if (sparkLane === 1) {
    // Top opening (risky): center of top gap
    sparkY = railTop + topH + (playH - topH - botH) * 0.5;
  } else {
    sparkY = railBot - botH - (playH - topH - botH) * 0.5;
  }
  // Actually the safe opening center should be different...
  // Risky lane is the blocked side. Spark should be placed where there's a small gap
  // For non-split: the "safe" opening is the big gap. The small gap on the other side IS risky.
  // But we want sparks reachable - place them near the edge of safe zone on the risky side.
  if (type !== GT.FLIPLOCK) {
    // Place spark in the safe opening but close to the dangerous edge
    if (safeLane === 1) {
      // Safe = top. Spark at the bottom edge of the safe opening (risky)
      sparkY = railTop + topH + gapPx * 0.8;
    } else {
      // Safe = bottom. Spark at the top edge of the safe opening (risky)
      sparkY = railBot - botH - gapPx * 0.8;
    }
    sparkY = clamp(sparkY, railTop + ORB_R + 2, railBot - ORB_R - 2);
    sparks.push({ x: x + GATE_W / 2, y: sparkY, alive: true, t: Math.random() * 6, gateX: x });
  }

  return x;
}

function spawnSplitGate(x, type, openingH, midH) {
  // Split gate: top opening, middle block, bottom opening
  const g = {
    x, type, safeLane: 2,
    topH: 0, botH: 0,
    splitOpenH: openingH, splitMidH: midH,
    w: GATE_W,
    pulsePhase: 0, pulseAmp: 0,
    flipLockStart: 0,
    scored: false, edged: false, comboChecked: false,
    split: true
  };
  gates.push(g);

  // Spark in one of the openings (random)
  const sparkTop = Math.random() < 0.5;
  let sparkY;
  if (sparkTop) {
    sparkY = railTop + openingH * 0.5;
  } else {
    sparkY = railBot - openingH * 0.5;
  }
  sparks.push({ x: x + GATE_W / 2, y: sparkY, alive: true, t: Math.random() * 6, gateX: x });
  return x;
}

/* ======== HELPERS ======== */
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }

function circleAABB(cx, cy, cr, rx, ry, rw, rh) {
  const nx = clamp(cx, rx, rx + rw);
  const ny = clamp(cy, ry, ry + rh);
  const dx = cx - nx, dy = cy - ny;
  return dx * dx + dy * dy < cr * cr;
}

/* ======== PARTICLES ======== */
function burst(x, y, count, baseHue, spd, life) {
  for (let i = 0; i < count && particles.length < PARTICLE_CAP; i++) {
    const a = Math.random() * Math.PI * 2;
    const v = (0.4 + Math.random()) * spd;
    particles.push({
      x, y,
      vx: Math.cos(a) * v, vy: Math.sin(a) * v,
      life, maxLife: life,
      hue: baseHue + Math.random() * 50 - 25,
      sz: 1.5 + Math.random() * 3
    });
  }
}

/* ======== FLIP ACTION ======== */
function doFlip() {
  if (state !== 'playing' || orbFlipping) return;

  // Check flip-lock zones
  for (const g of gates) {
    if (g.type === GT.FLIPLOCK) {
      if (orbX + ORB_R >= g.flipLockStart && orbX - ORB_R <= g.x) {
        // Blocked
        shakePow = Math.max(shakePow, 3);
        burst(orbX, orbY, 5, 0, 1.5, 0.35);
        return;
      }
    }
  }

  orbLane = 1 - orbLane;
  orbFromY = orbY;
  orbToY = orbLane === 0 ? railBot : railTop;
  orbFlipping = true;
  orbFlipT = 0;
  orbSquashX = 1.35; orbSquashY = 0.7;
  burst(orbX, orbY, 8, hue, 2.5, 0.45);
}

/* ======== INPUT ======== */
function handleInput(e) {
  if (e) e.preventDefault();
  if (state === 'start') { state = 'playing'; resetGame(); }
  else if (state === 'playing') doFlip();
  else if (state === 'gameover') { state = 'playing'; resetGame(); }
}

canvas.addEventListener('pointerdown', handleInput);
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault(); handleInput(null);
  }
});

/* ======== DIE ======== */
function die() {
  state = 'gameover';
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem(LS_KEY, String(bestScore));
  }
  shakePow = 14;
  burst(orbX, orbY, 35, 0, 4.5, 0.9);
  burst(orbX, orbY, 20, hue, 3.5, 0.7);
}

/* ======== MAIN LOOP ======== */
let lastT = 0;

function frame(ts) {
  requestAnimationFrame(frame);
  if (!lastT) { lastT = ts; return; }
  let dt = (ts - lastT) / 1000;
  lastT = ts;
  dt = Math.min(dt, 0.05); // clamp

  computeRails();
  hue = (hue + dt * 18) % 360;

  // Shake decay
  if (shakePow > 0.2) {
    shakeX = (Math.random() - 0.5) * shakePow * 2;
    shakeY = (Math.random() - 0.5) * shakePow * 2;
    shakePow *= Math.pow(0.06, dt); // exponential decay
  } else { shakeX = 0; shakeY = 0; shakePow = 0; }

  if (edgeAlpha > 0) edgeAlpha -= dt * 2.5;
  if (speedFlash > 0) speedFlash -= dt * 1.8;

  /* ---- PLAYING STATE UPDATE ---- */
  if (state === 'playing') {
    // Speed ramp
    scrollSpeed = Math.min(MAX_SCROLL, BASE_SCROLL + dist * SPEED_RAMP);
    const spd = scrollSpeed;

    dist += spd;

    // Speed level up
    const sl = Math.floor(dist / 800);
    if (sl > speedLevel) {
      speedLevel = sl;
      speedFlash = 1;
      shakePow = Math.max(shakePow, 4);
    }

    // Orb movement (flip arc)
    if (orbFlipping) {
      orbFlipT += dt * FLIP_SPEED;
      if (orbFlipT >= 1) { orbFlipT = 1; orbFlipping = false; }
      // Smooth ease
      const t = orbFlipT;
      const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      orbY = orbFromY + (orbToY - orbFromY) * ease;
      // Arc offset (horizontal wiggle for feel - skip, keep vertical)
    } else {
      // Snap to rail
      orbY = orbLane === 0 ? railBot : railTop;
    }

    // Landing squash
    if (!orbFlipping) {
      orbSquashX += (1 - orbSquashX) * Math.min(1, dt * 12);
      orbSquashY += (1 - orbSquashY) * Math.min(1, dt * 12);
    }

    // Score = distance + combo bonus
    score = Math.floor(dist * 0.12) + combo * comboMult * 5;

    // Scroll & process gates
    for (let i = gates.length - 1; i >= 0; i--) {
      const g = gates[i];
      g.x -= spd;
      if (g.flipLockStart) g.flipLockStart -= spd;

      if (g.x + g.w < -60) { gates.splice(i, 1); continue; }

      // Pulse animation
      if (g.type === GT.PULSE) {
        g.pulsePhase += dt * 3.2;
      }

      // Collision
      if (g.x < orbX + ORB_R + 2 && g.x + g.w > orbX - ORB_R - 2) {
        if (collideGate(g)) { die(); return; }
        // Edge / near-miss check
        if (!g.edged) {
          if (checkEdge(g)) {
            g.edged = true;
            edgeAlpha = 1; edgeTimer = 0;
            score += 15;
            burst(orbX, orbY, 6, 55, 1.8, 0.4);
            shakePow = Math.max(shakePow, 2.5);
          }
        }
      }

      // Mark scored
      if (!g.scored && g.x + g.w < orbX - ORB_R) {
        g.scored = true;
      }

      // Combo break check
      if (g.scored && !g.comboChecked) {
        g.comboChecked = true;
        let hadSpark = false, collected = false;
        for (const s of sparks) {
          if (Math.abs(s.gateX - (g.x + spd * 2)) < GATE_W * 3 ||
              Math.abs(s.gateX - g.x) < GATE_W * 3) {
            // This is approximate; gateX shifts, so use original relationship
          }
        }
        // Simpler: check if any spark near this gate's original x was skipped
        for (const s of sparks) {
          if (Math.abs(s.x - g.x) < MIN_GATE_SPACING * 0.6) {
            hadSpark = true;
            if (!s.alive) collected = true;
          }
        }
        if (hadSpark && !collected) {
          combo = 0; comboMult = 1;
        }
      }
    }

    // Keep gate pipeline full
    let rightmost = 0;
    for (const g of gates) { if (g.x > rightmost) rightmost = g.x; }
    while (rightmost < W + 300) {
      rightmost = spawnGateAt(rightmost);
    }

    // Scroll & collide sparks
    for (let i = sparks.length - 1; i >= 0; i--) {
      const s = sparks[i];
      s.x -= spd;
      s.gateX -= spd;
      s.t += dt * 5;
      if (s.x < -30) { sparks.splice(i, 1); continue; }
      if (!s.alive) continue;
      const dx = orbX - s.x, dy = orbY - s.y;
      if (dx * dx + dy * dy < (ORB_R + SPARK_R + 2) * (ORB_R + SPARK_R + 2)) {
        s.alive = false;
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        comboMult = combo >= 5 ? 3 : combo >= 2 ? 2 : 1;
        burst(s.x, s.y, 14, 50, 3, 0.55);
        shakePow = Math.max(shakePow, 2);
      }
    }

    // Rail bounds
    orbY = clamp(orbY, railTop, railBot);
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.vx *= Math.pow(0.92, 60 * dt);
    p.vy *= Math.pow(0.92, 60 * dt);
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  displayScore += (score - displayScore) * Math.min(1, dt * 8);

  render();
}

/* ======== COLLISION HELPERS ======== */
function getGateBlocks(g) {
  // Returns array of {x,y,w,h} rectangles for collision
  const blocks = [];
  const po = g.type === GT.PULSE ? Math.sin(g.pulsePhase) * g.pulseAmp : 0;

  if (g.split) {
    // Split gate: middle block
    const midY = railTop + g.splitOpenH;
    const midH = g.splitMidH;
    if (midH > 2) blocks.push({ x: g.x, y: midY, w: g.w, h: midH });
  } else {
    let tH = g.topH + po;
    let bH = g.botH - po;
    tH = Math.max(0, tH);
    bH = Math.max(0, bH);
    if (tH > 1) blocks.push({ x: g.x, y: railTop, w: g.w, h: tH });
    if (bH > 1) blocks.push({ x: g.x, y: railBot - bH, w: g.w, h: bH });
  }
  return blocks;
}

function collideGate(g) {
  const blocks = getGateBlocks(g);
  const cr = ORB_R - 1.5; // small forgiveness
  for (const b of blocks) {
    if (circleAABB(orbX, orbY, cr, b.x, b.y, b.w, b.h)) return true;
  }
  return false;
}

function checkEdge(g) {
  const blocks = getGateBlocks(g);
  for (const b of blocks) {
    // Check proximity to each edge of block
    const edges = [
      b.y,          // top edge
      b.y + b.h     // bottom edge
    ];
    for (const ey of edges) {
      const dy = Math.abs(orbY - ey);
      if (dy < ORB_R + EDGE_THRESHOLD && dy > ORB_R - 2) {
        // Also check horizontal overlap
        if (orbX + ORB_R > b.x - 2 && orbX - ORB_R < b.x + b.w + 2) {
          return true;
        }
      }
    }
  }
  return false;
}

/* ======== RENDER ======== */
function render() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(-20, -20, W + 40, H + 40);

  // Subtle grid
  ctx.strokeStyle = 'rgba(30,30,70,0.12)';
  ctx.lineWidth = 1;
  const go = (dist * 0.4) % 40;
  for (let x = -go; x <= W + 40; x += 40) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y <= H; y += 40) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  computeRails();

  // Rails glow
  const rHue = hue;
  ctx.shadowColor = `hsla(${rHue},80%,55%,0.4)`;
  ctx.shadowBlur = 6;
  ctx.strokeStyle = `hsla(${rHue},60%,45%,0.5)`;
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, railTop); ctx.lineTo(W, railTop); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, railBot); ctx.lineTo(W, railBot); ctx.stroke();
  ctx.shadowBlur = 0;

  if (state === 'playing' || state === 'gameover') {
    drawGameWorld();
    drawHUD();
  }

  if (state === 'start') drawStartScreen();
  if (state === 'gameover') drawGameOverScreen();

  ctx.restore();
}

function drawGameWorld() {
  // Flip-lock zones
  for (const g of gates) {
    if (g.type === GT.FLIPLOCK && g.flipLockStart > -120) {
      const lx = g.flipLockStart;
      const lw = g.x - g.flipLockStart;
      if (lw > 0 && lx < W + 10) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        const clampedX = Math.max(0, lx);
        const clampedW = Math.min(lw, W - clampedX + 20);
        ctx.beginPath();
        ctx.rect(clampedX, railTop, clampedW, playH);
        ctx.clip();
        // Base fill
        ctx.fillStyle = 'hsla(0,60%,20%,0.25)';
        ctx.fillRect(clampedX, railTop, clampedW, playH);
        // Animated diagonal stripes
        const sw = 14;
        const soff = (dist * 1.5) % sw;
        for (let sx = clampedX - playH - soff; sx < clampedX + clampedW + playH; sx += sw) {
          ctx.fillStyle = 'hsla(0,70%,40%,0.15)';
          ctx.beginPath();
          ctx.moveTo(sx, railTop);
          ctx.lineTo(sx + sw * 0.5, railTop);
          ctx.lineTo(sx + sw * 0.5 + playH, railBot);
          ctx.lineTo(sx + playH, railBot);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
        // Border
        ctx.strokeStyle = 'hsla(0,60%,45%,0.4)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(clampedX, railTop, clampedW, playH);
        ctx.setLineDash([]);
        // "NO FLIP" label
        if (clampedW > 50) {
          ctx.fillStyle = `hsla(0,70%,50%,0.3)`;
          ctx.font = 'bold 10px "Segoe UI",system-ui,sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('NO FLIP', clampedX + clampedW / 2, railTop + playH / 2 + 4);
        }
      }
    }
  }

  // Gates
  for (const g of gates) {
    if (g.x > W + 40) continue;
    const blocks = getGateBlocks(g);
    const proximity = clamp(1 - (g.x - orbX) / 280, 0, 1);
    const bright = 25 + proximity * 30;
    let gH;
    if (g.type === GT.FLIPLOCK) gH = 0;
    else if (g.type === GT.PULSE) gH = 280;
    else if (g.type === GT.SPLIT) gH = 140;
    else gH = hue;

    ctx.shadowColor = `hsla(${gH},80%,${bright + 15}%,${0.25 + proximity * 0.4})`;
    ctx.shadowBlur = 5 + proximity * 10;

    for (const b of blocks) {
      // Main block
      ctx.fillStyle = `hsl(${gH},65%,${bright}%)`;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      // Inner bevel
      ctx.fillStyle = `hsla(${gH},80%,${bright + 20}%,0.25)`;
      ctx.fillRect(b.x + 2, b.y + 2, b.w - 4, b.h - 4);
      // Edge highlight
      ctx.fillStyle = `hsla(${gH},90%,${bright + 30}%,0.15)`;
      ctx.fillRect(b.x, b.y, b.w, 2);
    }
    ctx.shadowBlur = 0;

    // Pulse indicator lines
    if (g.type === GT.PULSE) {
      const pa = 0.3 + Math.sin(g.pulsePhase) * 0.2;
      ctx.fillStyle = `hsla(280,80%,60%,${pa})`;
      ctx.fillRect(g.x - 1, railTop, g.w + 2, 2);
      ctx.fillRect(g.x - 1, railBot - 2, g.w + 2, 2);
    }
  }

  // Sparks
  for (const s of sparks) {
    if (!s.alive || s.x < -20 || s.x > W + 20) continue;
    const glow = 0.6 + Math.sin(s.t) * 0.3;
    const sr = SPARK_R + Math.sin(s.t * 1.3) * 1.5;
    ctx.shadowColor = `hsla(50,100%,65%,${glow * 0.7})`;
    ctx.shadowBlur = 10;
    ctx.fillStyle = `hsla(50,100%,${55 + Math.sin(s.t) * 15}%,${0.85 + glow * 0.15})`;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y - sr);
    ctx.lineTo(s.x + sr * 0.65, s.y);
    ctx.lineTo(s.x, s.y + sr);
    ctx.lineTo(s.x - sr * 0.65, s.y);
    ctx.closePath();
    ctx.fill();
    // Inner bright
    ctx.fillStyle = 'hsla(45,100%,90%,0.5)';
    ctx.beginPath();
    ctx.arc(s.x, s.y, sr * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Orb
  const cg = clamp(combo, 0, 8) / 8;
  const orbHue = (hue + combo * 25) % 360;
  ctx.save();
  ctx.translate(orbX, orbY);
  if (orbFlipping) {
    const dir = orbLane === 1 ? -1 : 1;
    ctx.scale(
      1 + (orbSquashX - 1) * (1 - orbFlipT),
      1 + (orbSquashY - 1) * (1 - orbFlipT)
    );
  } else {
    ctx.scale(orbSquashX, orbSquashY);
  }

  // Combo aura
  if (combo > 0) {
    const ar = ORB_R + 5 + cg * 10;
    const ag = ctx.createRadialGradient(0, 0, ORB_R * 0.4, 0, 0, ar);
    ag.addColorStop(0, `hsla(${orbHue},100%,70%,${0.15 + cg * 0.35})`);
    ag.addColorStop(1, `hsla(${orbHue},100%,50%,0)`);
    ctx.fillStyle = ag;
    ctx.beginPath(); ctx.arc(0, 0, ar, 0, Math.PI * 2); ctx.fill();
  }

  // Orb body
  ctx.shadowColor = `hsla(${orbHue},100%,65%,0.7)`;
  ctx.shadowBlur = 8 + cg * 14;
  ctx.fillStyle = `hsl(${orbHue},75%,60%)`;
  ctx.beginPath(); ctx.arc(0, 0, ORB_R, 0, Math.PI * 2); ctx.fill();
  // Highlight
  ctx.fillStyle = 'hsla(0,0%,100%,0.35)';
  ctx.beginPath(); ctx.arc(-2.5, -2.5, ORB_R * 0.4, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Particles
  for (const p of particles) {
    const a = clamp(p.life / p.maxLife, 0, 1);
    const s = p.sz * a;
    ctx.fillStyle = `hsla(${p.hue},80%,60%,${a * 0.8})`;
    ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);
  }
}

function drawHUD() {
  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(Math.floor(displayScore), 14, 10);

  // Combo
  if (comboMult > 1) {
    ctx.fillStyle = `hsla(50,100%,70%,0.85)`;
    ctx.font = 'bold 13px "Segoe UI",system-ui,sans-serif';
    ctx.fillText(`x${comboMult} COMBO (${combo})`, 14, 34);
  } else if (combo > 0) {
    ctx.fillStyle = `hsla(50,100%,60%,0.6)`;
    ctx.font = '12px "Segoe UI",system-ui,sans-serif';
    ctx.fillText(`streak: ${combo}`, 14, 34);
  }

  ctx.textBaseline = 'alphabetic';

  // Edge flash
  if (edgeAlpha > 0) {
    ctx.fillStyle = `hsla(55,100%,70%,${clamp(edgeAlpha, 0, 1)})`;
    ctx.font = 'bold 18px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('EDGE!', W / 2, H * 0.40);
  }

  // Speed up flash
  if (speedFlash > 0) {
    ctx.fillStyle = `hsla(${hue},80%,65%,${clamp(speedFlash * 0.7, 0, 1)})`;
    ctx.font = 'bold 20px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('SPEED UP!', W / 2, H * 0.5);
  }
}

function drawStartScreen() {
  ctx.fillStyle = 'rgba(8,8,22,0.88)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Title
  ctx.shadowColor = `hsla(${hue},100%,60%,0.5)`;
  ctx.shadowBlur = 24;
  ctx.fillStyle = `hsl(${hue},75%,68%)`;
  ctx.font = 'bold 38px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('GRAVITY', W / 2, H * 0.28);
  ctx.fillText('FLIP', W / 2, H * 0.28 + 44);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.fillStyle = 'hsla(0,0%,100%,0.4)';
  ctx.font = '12px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('C O M B O   G A T E S', W / 2, H * 0.28 + 72);

  // Instructions
  ctx.fillStyle = 'hsla(0,0%,100%,0.6)';
  ctx.font = '13px "Segoe UI",system-ui,sans-serif';
  const lines = [
    'Tap or press Space to flip gravity',
    'Navigate through gate openings',
    'Collect \u2666 sparks for combo multiplier',
    'Graze gates for EDGE! bonus points',
    'Watch for NO FLIP zones!'
  ];
  lines.forEach((t, i) => ctx.fillText(t, W / 2, H * 0.48 + i * 22));

  // Blink tap
  const blink = 0.4 + Math.sin(Date.now() * 0.004) * 0.4;
  ctx.fillStyle = `hsla(0,0%,100%,${blink + 0.2})`;
  ctx.font = 'bold 17px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('TAP TO START', W / 2, H * 0.76);

  // Best
  if (bestScore > 0) {
    ctx.fillStyle = 'hsla(50,70%,60%,0.6)';
    ctx.font = '13px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('BEST: ' + bestScore, W / 2, H * 0.83);
  }
}

function drawGameOverScreen() {
  ctx.fillStyle = 'rgba(8,8,22,0.82)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  ctx.fillStyle = 'hsla(0,75%,55%,0.9)';
  ctx.font = 'bold 30px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('GAME OVER', W / 2, H * 0.28);

  ctx.fillStyle = 'hsla(0,0%,100%,0.4)';
  ctx.font = '13px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('SCORE', W / 2, H * 0.35);

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 44px "Segoe UI",system-ui,sans-serif';
  ctx.fillText(score, W / 2, H * 0.44);

  ctx.fillStyle = 'hsla(50,80%,60%,0.85)';
  ctx.font = 'bold 20px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('BEST: ' + bestScore, W / 2, H * 0.53);

  if (maxCombo > 1) {
    ctx.fillStyle = 'hsla(50,90%,65%,0.6)';
    ctx.font = '14px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('Best Combo: x' + (maxCombo >= 5 ? 3 : maxCombo >= 2 ? 2 : 1) + ' (' + maxCombo + ' sparks)', W / 2, H * 0.60);
  }

  const blink = 0.4 + Math.sin(Date.now() * 0.004) * 0.4;
  ctx.fillStyle = `hsla(0,0%,100%,${blink + 0.2})`;
  ctx.font = 'bold 17px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('TAP TO RETRY', W / 2, H * 0.76);
}

/* ======== BOOT ======== */
requestAnimationFrame(frame);

})();
</script>
</body>
</html>