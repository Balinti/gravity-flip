<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="theme-color" content="#0a0e1a">
<link rel="canonical" href="https://balinti.github.io/gravity-flip/">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity in this fast-paced neon runner. Dodge pulse gates, collect charge orbs, and chain combos for massive scores!">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Flip - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity in this fast-paced neon runner. Dodge pulse gates, collect charge orbs, and chain combos for massive scores!">
<meta name="twitter:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0e1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;display:flex;flex-direction:column;justify-content:center;align-items:center;touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none}
#game-container{position:relative;width:100%;max-width:420px;max-height:750px;aspect-ratio:420/750;background:#0a0e1a;overflow:hidden;border-radius:4px}
canvas{display:block;width:100%;height:100%}
#seo-text{position:absolute;bottom:0;left:0;right:0;color:rgba(255,255,255,0.06);font-size:7px;line-height:1.2;padding:2px 6px;pointer-events:none;z-index:0}
</style>
</head>
<body>
<div id="game-container">
<canvas id="gc"></canvas>
<div id="seo-text">Gravity Flip: Pulse Gates - A hyper-casual HTML5 game. Tap or press Space to flip gravity between floor and ceiling rails. Navigate through pulse gates with color-coded safe zones. Cyan gates are safe at top, magenta at bottom, yellow require center passage. Collect charge orbs for combo shields and score multipliers. Chain near-miss passes for massive combo scores. Free to play in any browser.</div>
</div>

<script>
'use strict';
(()=>{

/* ═══════════════════════════════════════
   GRAVITY FLIP: PULSE GATES
   Hyper-casual HTML5 Canvas game
   ═══════════════════════════════════════ */

// --- Canvas Setup ---
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

let W, H, DPR;

function resize() {
  const rect = container.getBoundingClientRect();
  DPR = Math.min(window.devicePixelRatio || 1, 2.5);
  W = rect.width;
  H = rect.height;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// --- Constants ---
const RAIL_MARGIN = 55;
const PLAYER_R = 11;
const GRAVITY_ACCEL = 2600;
const FLIP_IMPULSE = 580;
const BASE_SPEED = 135;
const MAX_SPEED = 310;
const GATE_W = 16;
const GAP_BIG = 105;
const GAP_SMALL = 68;
const MIN_SPACING = 175;
const COYOTE = 0.045; // seconds of collision grace
const ORB_R = 9;
const NEAR_MISS_MARGIN = 16;
const LS_KEY = 'gravityFlipHighScore';

// --- State ---
let state = 'start';
let score = 0;
let best = parseInt(localStorage.getItem(LS_KEY)) || 0;
let combo = 0;
let comboMult = 1;
let orbShield = false;
let elapsed = 0;
let scrollSpd = BASE_SPEED;
let screenShake = 0;
let slowMo = 0;
let deathFlash = 0;
let hueShift = 0;
let railTop, railBot;

// Player
const player = { x: 0, y: 0, vy: 0, grav: 1, onRail: true };

// Collections
let gates = [];
let orbs = [];
let particles = [];
let speedLines = [];
let lastGateX = 0;
let lastSafe = 'top';
let gateNum = 0;

// --- WebAudio (optional, muted until first interaction) ---
let audioCtx = null;
let audioReady = false;

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioReady = true;
  } catch(e) { audioReady = false; }
}

function tone(freq, dur, type, vol) {
  if (!audioReady || !audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type || 'sine';
    o.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.07, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}

function sfxFlip()     { tone(440, 0.07, 'sine', 0.05); }
function sfxPass()     { tone(620, 0.1, 'triangle', 0.04); }
function sfxNearMiss() { tone(880, 0.14, 'sine', 0.06); tone(1100, 0.1, 'sine', 0.04); }
function sfxOrb()      { tone(1200, 0.18, 'sine', 0.08); tone(1500, 0.12, 'triangle', 0.05); }
function sfxDeath()    { tone(110, 0.35, 'sawtooth', 0.12); tone(80, 0.45, 'square', 0.07); }

// --- Utility ---
function lerp(a, b, t) { return a + (b - a) * t; }
function rand(a, b) { return Math.random() * (b - a) + a; }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }

// --- Particle System (capped for performance) ---
const MAX_PARTICLES = 100;

function emitP(x, y, n, color, speed, life) {
  for (let i = 0; i < n && particles.length < MAX_PARTICLES; i++) {
    const a = Math.random() * 6.2832;
    const s = rand(speed * 0.25, speed);
    particles.push({
      x, y,
      vx: Math.cos(a) * s,
      vy: Math.sin(a) * s,
      life: rand(life * 0.5, life),
      maxLife: life,
      color,
      sz: rand(1.5, 3.5)
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 40 * dt; // slight gravity on particles
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    const a = clamp(p.life / p.maxLife, 0, 1);
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.sz * 0.5, p.y - p.sz * 0.5, p.sz, p.sz);
  }
  ctx.globalAlpha = 1;
}

// --- Speed Lines ---
function updateSpeedLines(dt) {
  for (let i = speedLines.length - 1; i >= 0; i--) {
    speedLines[i].x -= speedLines[i].spd * dt;
    if (speedLines[i].x + speedLines[i].len < 0) speedLines.splice(i, 1);
  }
  if (speedLines.length < 15 && Math.random() < dt * scrollSpd * 0.04) {
    speedLines.push({
      x: W + 5,
      y: rand(railTop + 10, railBot - 10),
      len: rand(12, 40),
      spd: rand(scrollSpd * 1.4, scrollSpd * 2.2),
      alpha: rand(0.03, 0.1)
    });
  }
}

function drawSpeedLines() {
  ctx.lineWidth = 1;
  for (const l of speedLines) {
    ctx.globalAlpha = l.alpha;
    ctx.strokeStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(l.x, l.y);
    ctx.lineTo(l.x + l.len, l.y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

// --- Gate color language ---
// Cyan = top safe, Magenta = bottom safe, Yellow = center-only
function gateHSL(type) {
  if (type === 'top')    return [185, 100, 55];
  if (type === 'bottom') return [300, 100, 60];
  return [50, 100, 55]; // center
}

function gateCSS(type) {
  const [h, s, l] = gateHSL(type);
  return `hsl(${h},${s}%,${l}%)`;
}

// --- Gate creation ---
function makeGate(x, safeType, gapSize) {
  const tunnelH = railBot - railTop;
  let gapY;
  if (safeType === 'top') {
    gapY = railTop + gapSize * 0.5 + 10;
  } else if (safeType === 'bottom') {
    gapY = railBot - gapSize * 0.5 - 10;
  } else {
    gapY = (railTop + railBot) * 0.5;
  }
  return {
    x, w: GATE_W, safeType, gapSize, gapY,
    passed: false, scored: false
  };
}

// --- Spawner logic ---
function gapSize() {
  if (elapsed < 10)  return GAP_BIG;
  if (elapsed < 25)  return lerp(GAP_BIG, GAP_BIG * 0.85, (elapsed - 10) / 15);
  if (elapsed < 45)  return lerp(GAP_BIG * 0.85, GAP_SMALL + 12, (elapsed - 25) / 20);
  return lerp(GAP_SMALL + 12, GAP_SMALL, clamp((elapsed - 45) / 40, 0, 1));
}

function spacing() {
  const extra = elapsed < 10 ? 75 : elapsed < 25 ? 50 : elapsed < 45 ? 28 : 12;
  return MIN_SPACING + rand(0, extra);
}

function pickSafe() {
  // Phase-based selection with fairness rules
  if (elapsed < 10) {
    // Only top/bottom alternating
    return lastSafe === 'top' ? 'bottom' : 'top';
  }
  if (elapsed < 25) {
    // Introduce center occasionally
    if (Math.random() < 0.18 && lastSafe !== 'center') return 'center';
    return lastSafe === 'top' ? 'bottom' : 'top';
  }
  // 25s+: full mix, never center after center
  if (lastSafe === 'center') {
    return Math.random() < 0.5 ? 'top' : 'bottom';
  }
  const r = Math.random();
  if (r < 0.22) return 'center';
  if (lastSafe === 'top') return Math.random() < 0.65 ? 'bottom' : 'top';
  return Math.random() < 0.65 ? 'top' : 'bottom';
}

function spawnGates() {
  const edge = W + 60;
  while (lastGateX < edge + 350) {
    const sp = spacing();
    lastGateX += sp;
    const safe = pickSafe();
    const gap = gapSize();
    gates.push(makeGate(lastGateX, safe, gap));
    lastSafe = safe;
    gateNum++;

    // Orb at center line between gates (after 10s, 28% chance)
    if (elapsed > 10 && Math.random() < 0.28) {
      orbs.push({
        x: lastGateX - sp * 0.5,
        y: (railTop + railBot) * 0.5,
        alive: true,
        pulse: rand(0, 6.28)
      });
    }
  }
}

// --- Initialize a round ---
function initRound() {
  railTop = RAIL_MARGIN;
  railBot = H - RAIL_MARGIN;

  player.x = W * 0.2;
  player.y = railBot - PLAYER_R;
  player.vy = 0;
  player.grav = 1; // 1 = down, -1 = up
  player.onRail = true;

  gates = [];
  orbs = [];
  particles = [];
  speedLines = [];

  score = 0;
  combo = 0;
  comboMult = 1;
  orbShield = false;
  elapsed = 0;
  scrollSpd = BASE_SPEED;
  screenShake = 0;
  slowMo = 0;
  deathFlash = 0;
  hueShift = 0;
  lastGateX = W * 0.55;
  lastSafe = 'top';
  gateNum = 0;

  spawnGates();
}

// --- Flip gravity ---
function flipGravity() {
  if (state !== 'playing') return;
  player.grav *= -1;
  player.onRail = false;
  player.vy = -player.grav * FLIP_IMPULSE;
  sfxFlip();
  const col = player.grav > 0 ? 'hsl(185,100%,70%)' : 'hsl(300,100%,70%)';
  emitP(player.x, player.y, 4, col, 70, 0.25);
}

// --- Input ---
function handleInput(e) {
  if (e && e.preventDefault) e.preventDefault();
  initAudio();
  if (state === 'start') {
    state = 'playing';
    initRound();
    return;
  }
  if (state === 'gameover') {
    state = 'playing';
    initRound();
    return;
  }
  if (state === 'playing') {
    flipGravity();
  }
}

canvas.addEventListener('pointerdown', handleInput);
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    handleInput(e);
  }
});

// --- Collision: circle vs rect ---
function circRect(cx, cy, cr, rx, ry, rw, rh) {
  const nx = clamp(cx, rx, rx + rw);
  const ny = clamp(cy, ry, ry + rh);
  const dx = cx - nx, dy = cy - ny;
  return dx * dx + dy * dy < cr * cr;
}

function hitGate(g) {
  const gt = g.gapY - g.gapSize * 0.5;
  const gb = g.gapY + g.gapSize * 0.5;
  const pr = PLAYER_R - 1.5; // tiny forgiveness (coyote)
  // Upper barrier
  if (circRect(player.x, player.y, pr, g.x, railTop, g.w, gt - railTop)) return true;
  // Lower barrier
  if (circRect(player.x, player.y, pr, g.x, gb, g.w, railBot - gb)) return true;
  return false;
}

// --- Near-miss detection ---
function isNearMiss(g) {
  const gt = g.gapY - g.gapSize * 0.5;
  const gb = g.gapY + g.gapSize * 0.5;
  const dTop = Math.abs(player.y - gt);
  const dBot = Math.abs(player.y - gb);
  if (Math.min(dTop, dBot) < NEAR_MISS_MARGIN) return true;
  // Center gate: reward being near center
  if (g.safeType === 'center' && Math.abs(player.y - g.gapY) < 18) return true;
  return false;
}

// --- Death ---
function die() {
  state = 'gameover';
  if (score > best) {
    best = score;
    localStorage.setItem(LS_KEY, best.toString());
  }
  screenShake = 0.4;
  slowMo = 0.25;
  deathFlash = 0.12;
  sfxDeath();
  emitP(player.x, player.y, 28, '#ff4444', 190, 0.55);
  emitP(player.x, player.y, 14, '#ffaa00', 140, 0.45);
  emitP(player.x, player.y, 8, '#ffffff', 160, 0.35);
}

// --- Update ---
let lastT = 0;

function update(dt) {
  // Particles & shake always update
  updateParticles(dt);
  if (screenShake > 0) screenShake = Math.max(0, screenShake - dt * 2.5);
  if (deathFlash > 0) deathFlash -= dt;

  if (state !== 'playing') return;

  // Slow-mo
  let eDt = dt;
  if (slowMo > 0) { eDt *= 0.3; slowMo -= dt; }

  elapsed += eDt;
  hueShift = (elapsed * 7 + combo * 4) % 360;

  // Speed ramp
  scrollSpd = lerp(BASE_SPEED, MAX_SPEED, clamp(elapsed / 100, 0, 1));

  // --- Player physics ---
  if (!player.onRail) {
    player.vy += player.grav * GRAVITY_ACCEL * eDt;
    player.y += player.vy * eDt;
    // Clamp to rails
    if (player.grav > 0 && player.y >= railBot - PLAYER_R) {
      player.y = railBot - PLAYER_R;
      player.vy = 0;
      player.onRail = true;
    }
    if (player.grav < 0 && player.y <= railTop + PLAYER_R) {
      player.y = railTop + PLAYER_R;
      player.vy = 0;
      player.onRail = true;
    }
  } else {
    player.y = player.grav > 0 ? railBot - PLAYER_R : railTop + PLAYER_R;
  }

  // --- Scroll ---
  const dx = scrollSpd * eDt;

  for (let i = gates.length - 1; i >= 0; i--) {
    gates[i].x -= dx;
    if (gates[i].x + gates[i].w < -30) gates.splice(i, 1);
  }
  for (let i = orbs.length - 1; i >= 0; i--) {
    orbs[i].x -= dx;
    orbs[i].pulse += eDt * 3.5;
    if (orbs[i].x < -30) orbs.splice(i, 1);
  }
  lastGateX -= dx;
  spawnGates();
  updateSpeedLines(eDt);

  // --- Gate collision & scoring ---
  for (const g of gates) {
    const overX = player.x + PLAYER_R > g.x && player.x - PLAYER_R < g.x + g.w;

    if (overX && !g.passed) {
      if (hitGate(g)) {
        if (orbShield) {
          // Shield absorbs
          orbShield = false;
          g.passed = true;
          g.scored = true;
          emitP(player.x, player.y, 10, '#00ffff', 110, 0.3);
          screenShake = 0.08;
          sfxPass();
        } else {
          die();
          return;
        }
      }
    }

    // Gate cleared
    if (!g.scored && g.x + g.w < player.x - PLAYER_R) {
      g.passed = true;
      g.scored = true;
      sfxPass();

      const near = isNearMiss(g);
      const centerBonus = g.safeType === 'center' && Math.abs(player.y - g.gapY) < 22;

      if (near || centerBonus) {
        // Good pass: combo grows
        combo++;
        comboMult = 1 + Math.floor(combo / 3) * 0.5;
        const bonus = centerBonus ? 15 : 8;
        score += Math.round((10 + bonus) * comboMult);
        sfxNearMiss();
        const col = gateCSS(g.safeType);
        emitP(g.x + g.w, g.gapY, 8, col, 90, 0.3);
        emitP(g.x + g.w, g.gapY, 3, '#fff', 60, 0.2);
        screenShake = 0.04;
      } else {
        // Sloppy pass: combo resets
        combo = 0;
        comboMult = 1;
        score += 10;
        emitP(g.x + g.w, player.y, 2, '#888', 30, 0.15);
      }
    }
  }

  // --- Orb collection ---
  for (const orb of orbs) {
    if (!orb.alive) continue;
    const ox = player.x - orb.x, oy = player.y - orb.y;
    if (ox * ox + oy * oy < (PLAYER_R + ORB_R + 3) * (PLAYER_R + ORB_R + 3)) {
      orb.alive = false;
      orbShield = true;
      score += Math.round(25 * comboMult);
      combo += 2;
      comboMult = 1 + Math.floor(combo / 3) * 0.5;
      sfxOrb();
      emitP(orb.x, orb.y, 14, '#ffff00', 120, 0.4);
      emitP(orb.x, orb.y, 7, '#00ffff', 90, 0.3);
      screenShake = 0.07;
    }
  }

  // --- Player trail ---
  if (Math.random() < 0.4) {
    const th = player.grav > 0 ? 185 : 300;
    emitP(player.x - 7, player.y, 1, `hsl(${th + hueShift * 0.1|0},70%,55%)`, 18, 0.2);
  }
}

// --- Draw ---
function draw() {
  ctx.save();

  // Screen shake offset
  if (screenShake > 0) {
    ctx.translate(rand(-screenShake * 7, screenShake * 7), rand(-screenShake * 7, screenShake * 7));
  }

  // Background gradient
  const bgH = (210 + hueShift * 0.25) % 360;
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, `hsl(${bgH},30%,5%)`);
  bg.addColorStop(0.5, `hsl(${(bgH + 15) % 360},22%,3.5%)`);
  bg.addColorStop(1, `hsl(${(bgH + 30) % 360},28%,6%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(-15, -15, W + 30, H + 30);

  if (state === 'start') {
    drawStart();
    ctx.restore();
    return;
  }

  // Death flash overlay
  if (deathFlash > 0) {
    ctx.fillStyle = `rgba(255,255,255,${clamp(deathFlash * 4, 0, 0.5)})`;
    ctx.fillRect(0, 0, W, H);
  }

  drawRails();
  drawSpeedLines();
  drawWarnings();
  drawGates();
  drawOrbs();
  drawParticles();
  drawPlayer();
  drawHUD();

  if (state === 'gameover') drawGameOver();

  ctx.restore();
}

function drawRails() {
  const glow = combo > 5 ? 0.55 : 0.3;
  const rh = (185 + hueShift * 0.15) % 360;

  ctx.shadowBlur = 6;

  // Top rail
  ctx.shadowColor = `hsl(${rh},100%,50%)`;
  ctx.strokeStyle = `hsla(${rh},75%,50%,${glow})`;
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, railTop); ctx.lineTo(W, railTop); ctx.stroke();

  // Bottom rail
  const rh2 = (rh + 115) % 360;
  ctx.shadowColor = `hsl(${rh2},100%,50%)`;
  ctx.strokeStyle = `hsla(${rh2},75%,50%,${glow})`;
  ctx.beginPath(); ctx.moveTo(0, railBot); ctx.lineTo(W, railBot); ctx.stroke();

  ctx.shadowBlur = 0;
}

function drawWarnings() {
  for (const g of gates) {
    if (g.passed || g.x <= player.x || g.x > W + 40) continue;
    const d = g.x - player.x;
    const a = clamp(1 - d / 280, 0, 0.25);
    if (a < 0.015) continue;
    ctx.globalAlpha = a * 0.45;
    ctx.strokeStyle = gateCSS(g.safeType);
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 7]);
    ctx.beginPath();
    ctx.moveTo(g.x + g.w * 0.5, railTop);
    ctx.lineTo(g.x + g.w * 0.5, railBot);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
  }
}

function drawGates() {
  for (const g of gates) {
    if (g.x > W + 25 || g.x + g.w < -25) continue;
    const [h, s, l] = gateHSL(g.safeType);
    const col = `hsl(${h},${s}%,${l}%)`;
    const gt = g.gapY - g.gapSize * 0.5;
    const gb = g.gapY + g.gapSize * 0.5;

    ctx.shadowColor = col;
    ctx.shadowBlur = 10;
    ctx.globalAlpha = g.scored ? 0.25 : 0.82;
    ctx.fillStyle = col;

    // Upper barrier
    if (gt > railTop + 1) {
      ctx.fillRect(g.x, railTop, g.w, gt - railTop);
    }
    // Lower barrier
    if (gb < railBot - 1) {
      ctx.fillRect(g.x, gb, g.w, railBot - gb);
    }

    // Gap edge highlights
    if (!g.scored) {
      ctx.globalAlpha = 0.45;
      ctx.fillStyle = `hsl(${h},${s}%,${Math.min(l + 20, 90)}%)`;
      ctx.fillRect(g.x - 1, gt - 2.5, g.w + 2, 2.5);
      ctx.fillRect(g.x - 1, gb, g.w + 2, 2.5);
    }

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
}

function drawOrbs() {
  for (const orb of orbs) {
    if (!orb.alive || orb.x > W + 25 || orb.x < -25) continue;
    const p = Math.sin(orb.pulse) * 0.3 + 0.7;
    const r = ORB_R * p + 2;

    ctx.shadowColor = '#ffff00';
    ctx.shadowBlur = 14;
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = '#ffff00';
    ctx.beginPath(); ctx.arc(orb.x, orb.y, r + 3, 0, 6.2832); ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(orb.x, orb.y, r * 0.55, 0, 6.2832); ctx.fill();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
}

function drawPlayer() {
  const px = player.x, py = player.y;
  const gh = player.grav > 0 ? 185 : 300;
  const cg = Math.min(combo * 2, 18);

  ctx.shadowColor = `hsl(${gh},100%,60%)`;
  ctx.shadowBlur = 10 + cg;

  // Trail
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = `hsl(${gh},100%,60%)`;
  ctx.beginPath(); ctx.ellipse(px - 9, py, 16, PLAYER_R * 0.65, 0, 0, 6.2832); ctx.fill();

  // Core
  ctx.globalAlpha = 1;
  const cg2 = ctx.createRadialGradient(px, py, 0, px, py, PLAYER_R);
  cg2.addColorStop(0, '#fff');
  cg2.addColorStop(0.4, `hsl(${gh},88%,68%)`);
  cg2.addColorStop(1, `hsl(${gh},100%,42%)`);
  ctx.fillStyle = cg2;
  ctx.beginPath(); ctx.arc(px, py, PLAYER_R, 0, 6.2832); ctx.fill();

  // Shield ring
  if (orbShield) {
    ctx.strokeStyle = 'hsla(50,100%,60%,0.65)';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#ffff00';
    ctx.shadowBlur = 9;
    ctx.beginPath(); ctx.arc(px, py, PLAYER_R + 5, 0, 6.2832); ctx.stroke();
  }

  ctx.shadowBlur = 0;
}

function drawHUD() {
  // Score top-center
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 22px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(score.toString(), W * 0.5, 10);

  // Combo
  if (combo > 0) {
    const ca = clamp(combo / 3, 0, 1);
    const ch = (combo * 28 + 185) % 360;
    ctx.fillStyle = `hsla(${ch},100%,65%,${ca})`;
    ctx.font = 'bold 13px "Segoe UI",system-ui,sans-serif';
    ctx.fillText(`x${comboMult.toFixed(1)}  COMBO ${combo}`, W * 0.5, 36);
  }

  // Shield label
  if (orbShield) {
    ctx.fillStyle = 'hsla(50,100%,60%,0.75)';
    ctx.font = '10px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('SHIELD', W * 0.5, 52);
  }
}

function drawStart() {
  // BG
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, 'hsl(220,38%,5%)');
  bg.addColorStop(0.5, 'hsl(240,28%,3.5%)');
  bg.addColorStop(1, 'hsl(260,38%,6%)');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Decorative pulse core
  const pY = H * 0.25;
  ctx.shadowColor = 'hsl(185,100%,50%)';
  ctx.shadowBlur = 22;
  const pg = ctx.createRadialGradient(W * 0.5, pY, 0, W * 0.5, pY, 16);
  pg.addColorStop(0, '#fff');
  pg.addColorStop(0.45, 'hsl(185,90%,68%)');
  pg.addColorStop(1, 'hsl(185,100%,42%)');
  ctx.fillStyle = pg;
  ctx.beginPath(); ctx.arc(W * 0.5, pY, 16, 0, 6.2832); ctx.fill();
  ctx.shadowBlur = 0;

  // Title
  ctx.shadowColor = 'hsl(185,100%,50%)';
  ctx.shadowBlur = 20;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 36px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('GRAVITY FLIP', W * 0.5, H * 0.34);

  ctx.shadowBlur = 8;
  ctx.fillStyle = 'hsl(185,75%,58%)';
  ctx.font = '15px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('PULSE GATES', W * 0.5, H * 0.34 + 32);
  ctx.shadowBlur = 0;

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = '12px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('Tap or Space to flip gravity', W * 0.5, H * 0.48);
  ctx.fillText('Pass through gates to score', W * 0.5, H * 0.48 + 20);
  ctx.fillText('Near-miss = combo bonus!', W * 0.5, H * 0.48 + 40);

  // Gate color legend
  ctx.font = '12px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = 'hsl(185,100%,55%)';
  ctx.fillText('Cyan = Top safe', W * 0.5, H * 0.62);
  ctx.fillStyle = 'hsl(300,100%,60%)';
  ctx.fillText('Magenta = Bottom safe', W * 0.5, H * 0.62 + 18);
  ctx.fillStyle = 'hsl(50,100%,55%)';
  ctx.fillText('Yellow = Center only', W * 0.5, H * 0.62 + 36);

  // Tap prompt
  const ta = 0.45 + Math.sin(performance.now() * 0.002) * 0.3;
  ctx.fillStyle = `rgba(255,255,255,${ta})`;
  ctx.font = 'bold 17px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('TAP TO START', W * 0.5, H * 0.8);

  // Best
  if (best > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.28)';
    ctx.font = '12px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('Best: ' + best, W * 0.5, H * 0.87);
  }
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = '#ff4444';
  ctx.shadowBlur = 18;
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 30px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('GAME OVER', W * 0.5, H * 0.32);
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 24px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('Score: ' + score, W * 0.5, H * 0.44);

  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.font = '15px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('Best: ' + best, W * 0.5, H * 0.51);

  if (score > 0 && score >= best) {
    ctx.fillStyle = 'hsl(50,100%,60%)';
    ctx.font = 'bold 13px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('NEW BEST!', W * 0.5, H * 0.57);
  }

  const ta = 0.45 + Math.sin(performance.now() * 0.002) * 0.3;
  ctx.fillStyle = `rgba(255,255,255,${ta})`;
  ctx.font = 'bold 15px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('TAP TO RETRY', W * 0.5, H * 0.72);
}

// --- Main Loop ---
function loop(now) {
  if (!lastT) lastT = now;
  let dt = (now - lastT) * 0.001;
  lastT = now;
  if (dt > 0.1) dt = 0.016; // cap to prevent spiral

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// --- Boot ---
initRound();
state = 'start';
requestAnimationFrame(loop);

})();
</script>
</body>
</html>