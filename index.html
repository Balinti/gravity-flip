<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0b0f1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity up/down while dodging obstacles. Collect stars, build combos, and master the heat mechanic in this hyper-casual arcade game.">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0b0f1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center}
#wrap{position:relative;width:100%;max-width:420px;height:100vh;height:100dvh;max-height:750px;display:flex;flex-direction:column;align-items:center}
canvas{display:block;width:100%;flex:1;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer}
#info{color:rgba(255,255,255,0.25);font-size:11px;text-align:center;padding:6px 12px;line-height:1.4;flex-shrink:0}
</style>
</head>
<body>
<div id="wrap">
<canvas id="gc"></canvas>
<div id="info">Tap or press Space to flip gravity. Thread orbit rings to build combos &mdash; avoid fakes! Watch your heat meter and fill the pulse bar with stardust for a powerful phase-flip.</div>
</div>
<script>
'use strict';
(function(){

/* ═══════════════════════════════════════════
   GRAVITY FLIP: COMBO ORBITS
   ═══════════════════════════════════════════ */

// ── Canvas & DPR ──
const cvs = document.getElementById('gc');
const ctx = cvs.getContext('2d');
const wrap = document.getElementById('wrap');
let W, H, dpr;

function resize(){
  const r = wrap.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = r.width;
  H = r.height;
  cvs.width = W * dpr;
  cvs.height = H * dpr;
  cvs.style.width = W + 'px';
  cvs.style.height = H + 'px';
}
window.addEventListener('resize', resize);
resize();

// ── World constants (logical coordinates = pixel at dpr=1) ──
const WORLD_W = 420, WORLD_H = 750;
const CEIL_Y = 30, FLOOR_Y = 720;
const GRAV = 2400;
const TERM_VY = 1400;
const PLAYER_R = 12;

// combo thresholds → multipliers
const C_THRESH = [0, 2, 4, 7, 11, 16];
const C_MULT   = [1, 2, 3, 5, 8, 13];

// ── Persistence ──
const LS_KEY = 'gfco_bestScore';
let bestScore = 0;
function loadBest(){ try{ bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0; }catch(e){} }
function saveBest(){ try{ localStorage.setItem(LS_KEY, String(bestScore)); }catch(e){} }
loadBest();

// ── State ──
let state = 'start'; // start | playing | gameover
let score, tRun, gravDir, playerX, playerY, playerVY;
let heat, lastFlipT;
let pulseCharge, pulseActive, pulseTimer;
const PULSE_DUR = 0.35;
let combo, comboTier, comboMult;
let hue;
let obstacles, rings, dust, particles;
let spawnDist, totalDist;
let shakeMag, shakeX, shakeY, shakeDecay;
let gameOverDelay;

// ── Init ──
function initGame(){
  score = 0; tRun = 0;
  gravDir = 1;
  playerX = 80; playerY = WORLD_H * 0.5; playerVY = 0;
  heat = 0; lastFlipT = -1;
  pulseCharge = 0; pulseActive = false; pulseTimer = 0;
  combo = 0; comboTier = 0; comboMult = 1;
  obstacles = []; rings = []; dust = []; particles = [];
  spawnDist = 300; totalDist = 0;
  shakeMag = 0; shakeX = 0; shakeY = 0; shakeDecay = 0.92;
  gameOverDelay = 0;
}

// ── Helpers ──
function clamp(v, lo, hi){ return v < lo ? lo : v > hi ? hi : v; }
function getSpeed(){ return 260 + 22 * Math.log2(1 + tRun); }

function updateComboTier(){
  comboTier = 0;
  for(let i = C_THRESH.length - 1; i >= 0; i--){
    if(combo >= C_THRESH[i]){ comboTier = i; break; }
  }
  comboMult = C_MULT[comboTier];
}

function addShake(mag){
  shakeMag = Math.max(shakeMag, mag);
  shakeDecay = 0.90;
}

// ── Particles ──
function mkP(x, y, vx, vy, life, r, col){
  return { x, y, vx, vy, life, ml: life, r, col, alive: true };
}
function burst(x, y, n, spread, life, col){
  for(let i = 0; i < n; i++){
    const a = Math.random() * Math.PI * 2;
    const sp = spread * (0.3 + Math.random() * 0.7);
    particles.push(mkP(x, y, Math.cos(a)*sp, Math.sin(a)*sp, life*(0.6+Math.random()*0.4), 1.5+Math.random()*3, col));
  }
}

function updateParticles(dt){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.vx *= 0.97; p.vy *= 0.97;
    p.life -= dt;
    if(p.life <= 0) particles.splice(i, 1);
  }
}

// ── Flip ──
function flip(){
  gravDir *= -1;
  const now = tRun;
  const dt = now - lastFlipT;
  heat = clamp(heat + 0.18, 0, 1);
  if(dt < 0.22 && lastFlipT >= 0) heat = clamp(heat + 0.10, 0, 1);
  lastFlipT = now;

  // Pulse flip?
  if(pulseCharge >= 1 && !pulseActive){
    pulseActive = true;
    pulseTimer = PULSE_DUR;
    pulseCharge = 0;
    addShake(10);
    burst(playerX, playerY, 40, 350, 0.5, function(){ return 'hsl('+(hue+120)+',100%,75%)'; });
    // use color directly
    for(let i = 0; i < 40; i++){
      const a = Math.random() * Math.PI * 2, sp = 150 + Math.random() * 350;
      particles.push(mkP(playerX, playerY, Math.cos(a)*sp, Math.sin(a)*sp, 0.3+Math.random()*0.3, 3+Math.random()*3, 'hsl('+(hue+120)+',100%,75%)'));
    }
  }
  // normal flip particles
  for(let i = 0; i < 8; i++){
    const a = Math.random()*Math.PI*2, sp = 40+Math.random()*80;
    particles.push(mkP(playerX, playerY, Math.cos(a)*sp, Math.sin(a)*sp, 0.3, 2+Math.random()*2, 'hsl('+hue+',80%,60%)'));
  }
}

// ── Spawning ──
function spawnSet(){
  const rx = WORLD_W + 60;
  const rng = Math.random;
  const obs = [];

  // pattern cards with guaranteed solutions
  const pat = rng();
  if(pat < 0.25){
    // top only
    const h = 60 + rng()*100;
    obs.push({ x: rx, y: 0, w: 28+rng()*18, h: h, passed: false, buzzed: false });
  } else if(pat < 0.5){
    // bottom only
    const h = 60 + rng()*100;
    obs.push({ x: rx, y: FLOOR_Y - h, w: 28+rng()*18, h: h, passed: false, buzzed: false });
  } else if(pat < 0.8){
    // both with gap (guaranteed passable)
    let gapSz = 180 + rng()*120 - Math.min(tRun*0.8, 60);
    gapSz = Math.max(gapSz, 120);
    const gapC = CEIL_Y + 80 + rng()*(FLOOR_Y - CEIL_Y - 160);
    const w = 28+rng()*18;
    const topH = gapC - gapSz/2;
    const botY = gapC + gapSz/2;
    const botH = FLOOR_Y - botY;
    if(topH > 20) obs.push({ x: rx, y: 0, w: w, h: topH, passed: false, buzzed: false });
    if(botH > 20) obs.push({ x: rx, y: botY, w: w, h: botH, passed: false, buzzed: false });
  } else {
    // staggered: two blocks offset in x, one top one bottom
    const w = 24+rng()*14;
    const h1 = 50+rng()*70, h2 = 50+rng()*70;
    obs.push({ x: rx, y: 0, w: w, h: h1, passed: false, buzzed: false });
    obs.push({ x: rx + 100 + rng()*60, y: FLOOR_Y - h2, w: w, h: h2, passed: false, buzzed: false });
  }
  for(const o of obs) obstacles.push(o);

  // rings near midline
  if(rng() < 0.55){
    const fake = rng() < 0.18 + Math.min(tRun/120, 0.25);
    const ry = CEIL_Y + 80 + rng()*(FLOOR_Y - CEIL_Y - 160);
    rings.push({ x: rx + 40 + rng()*60, y: ry, r: 28, fake: fake, alive: true, t: 0 });
  }

  // stardust
  if(rng() < 0.4){
    const dy = CEIL_Y + 50 + rng()*(FLOOR_Y - CEIL_Y - 100);
    dust.push({ x: rx + 20 + rng()*80, y: dy, r: 6, alive: true, t: 0 });
  }
}

// ── Collision ──
function rectCirc(rx, ry, rw, rh, cx, cy, cr){
  const nx = clamp(cx, rx, rx+rw);
  const ny = clamp(cy, ry, ry+rh);
  const dx = cx - nx, dy = cy - ny;
  return dx*dx + dy*dy < cr*cr;
}

// ── Die ──
function die(){
  state = 'gameover';
  gameOverDelay = 0;
  if(score > bestScore){ bestScore = score; saveBest(); }
  addShake(20);
  // death burst
  for(let i = 0; i < 60; i++){
    const a = Math.random()*Math.PI*2, sp = 80+Math.random()*300;
    particles.push(mkP(playerX, playerY, Math.cos(a)*sp, Math.sin(a)*sp, 0.6+Math.random()*0.6, 3+Math.random()*4, 'hsl('+(hue+Math.random()*60-30)+',90%,65%)'));
  }
  // implosion
  for(let i = 0; i < 24; i++){
    const a = i/24*Math.PI*2, r = 160;
    particles.push(mkP(playerX+Math.cos(a)*r, playerY+Math.sin(a)*r, -Math.cos(a)*200, -Math.sin(a)*200, 0.5, 2.5, 'hsl('+hue+',70%,50%)'));
  }
}

// ── Input ──
let inputQ = [];
function onInput(e){
  if(e) e.preventDefault();
  if(state === 'start'){ state = 'playing'; initGame(); return; }
  if(state === 'gameover'){ if(gameOverDelay > 0.5){ state = 'start'; } return; }
  inputQ.push(1);
}
cvs.addEventListener('pointerdown', onInput);
document.addEventListener('keydown', function(e){
  if(e.code==='Space'||e.code==='Enter'||e.code==='ArrowUp'||e.code==='ArrowDown'){
    e.preventDefault(); onInput(null);
  }
});

// ── Update ──
function update(dt){
  hue = (hue + 25*dt) % 360;

  if(state === 'gameover'){
    gameOverDelay += dt;
    updateParticles(dt);
    if(shakeMag > 0.5){ shakeMag *= shakeDecay; shakeX=(Math.random()-0.5)*shakeMag; shakeY=(Math.random()-0.5)*shakeMag; } else { shakeX=shakeY=0;shakeMag=0; }
    return;
  }
  if(state !== 'playing') return;

  tRun += dt;

  // process flips
  while(inputQ.length){ inputQ.pop(); flip(); }

  // gravity
  playerVY += gravDir * GRAV * dt;
  playerVY = clamp(playerVY, -TERM_VY, TERM_VY);
  playerY += playerVY * dt;

  // clamp ceil/floor
  if(playerY - PLAYER_R < CEIL_Y){ playerY = CEIL_Y + PLAYER_R; playerVY = 0; }
  if(playerY + PLAYER_R > FLOOR_Y){ playerY = FLOOR_Y - PLAYER_R; playerVY = 0; }

  // heat cool
  heat = Math.max(0, heat - 0.22*dt);

  // pulse timer
  if(pulseActive){
    pulseTimer -= dt;
    if(pulseTimer <= 0){ pulseActive = false; pulseTimer = 0; }
  }

  // speed & scroll
  const spd = getSpeed();
  const scroll = spd * dt;
  totalDist += scroll;

  // spawn
  spawnDist -= scroll;
  if(spawnDist <= 0){
    spawnSet();
    const baseGap = 360 - 90*Math.min(tRun/60, 1);
    spawnDist = baseGap / (1 + 0.9*heat);
  }

  // move obstacles
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    o.x -= scroll;
    if(o.x + o.w < -60){ obstacles.splice(i, 1); continue; }

    // pass scoring
    if(!o.passed && o.x + o.w < playerX){
      o.passed = true;
      score += 1 * comboMult;
    }
    // near-miss buzz
    if(o.passed && !o.buzzed){
      const cx = clamp(playerX, o.x, o.x+o.w);
      const cy = clamp(playerY, o.y, o.y+o.h);
      const ddx = playerX-cx, ddy = playerY-cy;
      const dist = Math.sqrt(ddx*ddx+ddy*ddy);
      if(dist < PLAYER_R + 16){
        o.buzzed = true;
        score += 2 * comboMult;
        for(let j = 0; j < 6; j++){
          const a = Math.random()*Math.PI*2, sp = 50+Math.random()*60;
          particles.push(mkP(playerX, playerY, Math.cos(a)*sp, Math.sin(a)*sp, 0.25, 1.5, 'hsl('+(hue+60)+',100%,80%)'));
        }
      }
    }
  }

  // move rings
  for(let i = rings.length - 1; i >= 0; i--){
    const rr = rings[i];
    rr.x -= scroll;
    rr.t += dt * 4;
    if(rr.x < -60){ rings.splice(i, 1); continue; }
    if(!rr.alive) continue;

    const hf = 1 - 0.35*heat;
    const passR = rr.r * hf;
    const dx = playerX - rr.x, dy = playerY - rr.y;
    const d = Math.sqrt(dx*dx+dy*dy);
    if(d < passR + PLAYER_R){
      rr.alive = false;
      if(rr.fake){
        score += 3 * comboMult;
        combo = 0; // fakes break streak
      } else {
        score += 5 * comboMult;
        combo++;
      }
      updateComboTier();
      addShake(2 + comboMult * 0.5);
      const bc = rr.fake ? 'hsl('+hue+',30%,50%)' : 'hsl('+hue+',100%,70%)';
      for(let j = 0; j < 16; j++){
        const a = j/16*Math.PI*2, sp = 80+Math.random()*120;
        particles.push(mkP(rr.x, rr.y, Math.cos(a)*sp, Math.sin(a)*sp, 0.35, 2+Math.random()*2, bc));
      }
    }
  }

  // move dust
  for(let i = dust.length - 1; i >= 0; i--){
    const d = dust[i];
    d.x -= scroll;
    d.t += dt;
    if(d.x < -60){ dust.splice(i, 1); continue; }
    if(!d.alive) continue;
    const dx = playerX - d.x, dy = playerY - d.y;
    if(dx*dx+dy*dy < (PLAYER_R+d.r)*(PLAYER_R+d.r)){
      d.alive = false;
      pulseCharge = Math.min(1, pulseCharge + 0.15);
      score += 1;
      for(let j = 0; j < 8; j++){
        const a = Math.random()*Math.PI*2, sp = 40+Math.random()*60;
        particles.push(mkP(d.x, d.y, Math.cos(a)*sp, Math.sin(a)*sp, 0.3, 2, 'hsl(55,100%,80%)'));
      }
    }
  }

  // combo trail at tier >= x3
  if(comboTier >= 2 && Math.random() < 0.6){
    particles.push(mkP(playerX - 8+Math.random()*4, playerY+Math.random()*8-4, -30-Math.random()*20, (Math.random()-0.5)*20, 0.3, 1.5+Math.random(), 'hsl('+(hue+comboTier*20)+',90%,65%)'));
  }

  // collisions
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    if(rectCirc(o.x, o.y, o.w, o.h, playerX, playerY, PLAYER_R)){
      if(pulseActive){
        pulseActive = false; pulseTimer = 0;
        obstacles.splice(i, 1);
        addShake(6);
        for(let j = 0; j < 20; j++){
          const a = Math.random()*Math.PI*2, sp = 100+Math.random()*150;
          particles.push(mkP(playerX, playerY, Math.cos(a)*sp, Math.sin(a)*sp, 0.4, 3, 'hsl('+(hue+120)+',100%,80%)'));
        }
      } else {
        die(); return;
      }
    }
  }

  updateParticles(dt);

  // shake
  if(shakeMag > 0.5){ shakeMag *= shakeDecay; shakeX=(Math.random()-0.5)*shakeMag; shakeY=(Math.random()-0.5)*shakeMag; } else { shakeX=shakeY=0; shakeMag=0; }
}

// ── Drawing ──
function scX(){ return cvs.width / WORLD_W; }
function scY(){ return cvs.height / WORLD_H; }

function draw(){
  const sx = scX(), sy = scY();
  ctx.save();
  ctx.scale(sx, sy);
  ctx.translate(shakeX||0, shakeY||0);

  // bg gradient
  const grad = ctx.createLinearGradient(0,0,0,WORLD_H);
  grad.addColorStop(0, '#0b0f1a');
  grad.addColorStop(0.5, '#111827');
  grad.addColorStop(1, '#0b0f1a');
  ctx.fillStyle = grad;
  ctx.fillRect(-30,-30,WORLD_W+60,WORLD_H+60);

  // subtle bg stars
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  for(let i = 0; i < 40; i++){
    // deterministic positions using i
    const bx = ((i*137.5+totalDist*0.02*(1+i%3*0.3))%WORLD_W);
    const by = ((i*97.3)%WORLD_H);
    ctx.fillRect(bx, by, 1.2, 1.2);
  }

  // ceil/floor lines
  ctx.strokeStyle = 'hsla('+hue+',60%,40%,0.4)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0,CEIL_Y); ctx.lineTo(WORLD_W,CEIL_Y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,FLOOR_Y); ctx.lineTo(WORLD_W,FLOOR_Y); ctx.stroke();

  // obstacles
  for(const o of obstacles){
    if(o.x > WORLD_W+60 || o.x+o.w < -60) continue;
    const g = ctx.createLinearGradient(o.x,o.y,o.x+o.w,o.y+o.h);
    g.addColorStop(0, 'hsla('+(hue+180)+',70%,35%,0.85)');
    g.addColorStop(1, 'hsla('+(hue+200)+',80%,25%,0.9)');
    ctx.fillStyle = g;
    // rounded rect
    const rr = 4;
    ctx.beginPath();
    ctx.moveTo(o.x+rr, o.y);
    ctx.lineTo(o.x+o.w-rr, o.y);
    ctx.quadraticCurveTo(o.x+o.w, o.y, o.x+o.w, o.y+rr);
    ctx.lineTo(o.x+o.w, o.y+o.h-rr);
    ctx.quadraticCurveTo(o.x+o.w, o.y+o.h, o.x+o.w-rr, o.y+o.h);
    ctx.lineTo(o.x+rr, o.y+o.h);
    ctx.quadraticCurveTo(o.x, o.y+o.h, o.x, o.y+o.h-rr);
    ctx.lineTo(o.x, o.y+rr);
    ctx.quadraticCurveTo(o.x, o.y, o.x+rr, o.y);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = 'hsla('+(hue+180)+',80%,50%,0.5)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // rings
  for(const rr of rings){
    if(!rr.alive || rr.x > WORLD_W+60) continue;
    const hf = 1 - 0.35*heat;
    const drawR = rr.r * hf;
    ctx.save();
    ctx.translate(rr.x, rr.y);
    if(rr.fake){
      ctx.strokeStyle = 'hsla('+(hue+30)+',25%,40%,'+(0.4+0.15*Math.sin(rr.t))+')';
      ctx.lineWidth = 2;
      ctx.setLineDash([6,8]);
    } else {
      ctx.strokeStyle = 'hsla('+(hue+90)+',85%,65%,'+(0.7+0.3*Math.sin(rr.t))+')';
      ctx.lineWidth = 3;
      ctx.shadowColor = 'hsla('+(hue+90)+',100%,70%,0.5)';
      ctx.shadowBlur = 8;
    }
    ctx.beginPath(); ctx.arc(0,0,drawR,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // stardust
  for(const d of dust){
    if(!d.alive) continue;
    ctx.save();
    ctx.translate(d.x, d.y);
    const pulse = 1 + 0.2*Math.sin(d.t*6);
    ctx.fillStyle = 'hsla(55,100%,75%,'+(0.7+0.3*Math.sin(d.t*4))+')';
    ctx.shadowColor = 'hsla(55,100%,80%,0.6)';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    for(let i = 0; i < 5; i++){
      let a = -Math.PI/2 + i*Math.PI*2/5;
      const r = d.r * pulse;
      ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      a += Math.PI*2/10;
      ctx.lineTo(Math.cos(a)*r*0.45, Math.sin(a)*r*0.45);
    }
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // particles
  for(const p of particles){
    const alpha = Math.max(0, p.life / p.ml);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r*alpha, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // player
  if(state === 'playing' || state === 'gameover'){
    if(state === 'playing'){
      ctx.save();
      ctx.translate(playerX, playerY);
      // glow
      if(pulseActive){
        ctx.shadowColor = 'hsla('+(hue+120)+',100%,70%,0.8)';
        ctx.shadowBlur = 20;
        ctx.fillStyle = 'hsla('+(hue+120)+',100%,75%,0.8)';
      } else if(pulseCharge >= 1){
        ctx.shadowColor = 'hsla('+(hue+120)+',100%,70%,'+(0.4+0.4*Math.sin(tRun*8))+')';
        ctx.shadowBlur = 14;
        ctx.fillStyle = 'hsla('+hue+',90%,70%,0.95)';
      } else {
        ctx.shadowColor = 'hsla('+hue+',80%,60%,0.6)';
        ctx.shadowBlur = 10;
        ctx.fillStyle = 'hsla('+hue+',85%,65%,0.95)';
      }
      ctx.beginPath(); ctx.arc(0,0,PLAYER_R,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // highlight
      ctx.fillStyle = 'hsla('+(hue+20)+',100%,85%,0.5)';
      ctx.beginPath(); ctx.arc(-3,-3,PLAYER_R*0.4,0,Math.PI*2); ctx.fill();
      // direction arrow
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.beginPath();
      ctx.moveTo(0, gravDir*3);
      ctx.lineTo(-4, gravDir*-4);
      ctx.lineTo(4, gravDir*-4);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
  }

  // HUD (playing only)
  if(state === 'playing') drawHUD();

  // overlays
  if(state === 'start') drawOverlay('GRAVITY FLIP', 'Combo Orbits', 'Tap to Start', null);
  if(state === 'gameover') drawOverlay('GAME OVER', null, 'Tap to Retry', 'Score: '+score+'  Best: '+bestScore);

  ctx.restore();
}

function drawHUD(){
  // top-left: score + mult + combo
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 22px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(String(score), 14, 22);

  if(comboMult > 1){
    ctx.font = 'bold 14px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = 'hsla('+(hue+60)+',100%,70%,0.9)';
    ctx.fillText('x'+comboMult, 14, 40);
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '11px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('streak '+combo, 50, 40);
  }

  // top-right: heat + pulse bars
  const barW = 60, barH = 8;
  const barX = WORLD_W - barW - 12, barY = 12;

  // heat
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(barX, barY, barW, barH);
  const hc = heat < 0.5 ? 'hsl(200,70%,50%)' : heat < 0.8 ? 'hsl(40,90%,55%)' : 'hsl(0,90%,55%)';
  ctx.fillStyle = hc;
  ctx.fillRect(barX, barY, barW*heat, barH);
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.font = '9px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('HEAT', barX - 4, barY + 7);

  // pulse
  const pY = barY + barH + 5;
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(barX, pY, barW, barH);
  if(pulseCharge >= 1){
    const flash = 0.7 + 0.3*Math.sin(tRun*10);
    ctx.fillStyle = 'hsla('+(hue+120)+',100%,65%,'+flash+')';
    ctx.fillRect(barX, pY, barW, barH);
    ctx.fillStyle = 'hsla('+(hue+120)+',100%,90%,0.9)';
    ctx.font = 'bold 9px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('READY', barX - 4, pY + 7);
  } else {
    ctx.fillStyle = 'hsla(55,90%,60%,0.8)';
    ctx.fillRect(barX, pY, barW*pulseCharge, barH);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '9px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('PULSE', barX - 4, pY + 7);
  }
}

function drawOverlay(title, subtitle, action, extra){
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,WORLD_W,WORLD_H);

  ctx.textAlign = 'center';

  // title
  ctx.fillStyle = 'hsla('+hue+',80%,70%,0.95)';
  ctx.font = 'bold 36px "Segoe UI",system-ui,sans-serif';
  ctx.shadowColor = 'hsla('+hue+',100%,60%,0.5)';
  ctx.shadowBlur = 15;
  ctx.fillText(title, WORLD_W/2, WORLD_H*0.32);
  ctx.shadowBlur = 0;

  // subtitle
  if(subtitle){
    ctx.fillStyle = 'hsla('+(hue+40)+',70%,65%,0.8)';
    ctx.font = '16px "Segoe UI",system-ui,sans-serif';
    ctx.fillText(subtitle, WORLD_W/2, WORLD_H*0.38);
  }

  // extra (score line)
  if(extra){
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '18px "Segoe UI",system-ui,sans-serif';
    ctx.fillText(extra, WORLD_W/2, WORLD_H*0.46);
  }

  // action (tap to ...)
  const blink = 0.5 + 0.5*Math.sin(Date.now()/400);
  ctx.fillStyle = 'rgba(255,255,255,'+(0.4+0.5*blink)+')';
  ctx.font = '16px "Segoe UI",system-ui,sans-serif';
  ctx.fillText(action, WORLD_W/2, WORLD_H*0.56);

  // controls hint on start
  if(state === 'start'){
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '11px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('Space / Enter / Tap to flip gravity', WORLD_W/2, WORLD_H*0.64);
    ctx.fillText('Thread rings for combos \u2022 Collect stardust', WORLD_W/2, WORLD_H*0.68);
    if(bestScore > 0){
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillText('Best: '+bestScore, WORLD_W/2, WORLD_H*0.76);
    }
  }
}

// ── Main loop ──
hue = 200;
shakeX = shakeY = shakeMag = 0;
totalDist = 0;
gameOverDelay = 0;
particles = [];

let lastT = 0;
function frame(ts){
  requestAnimationFrame(frame);
  if(!lastT) lastT = ts;
  let dt = (ts - lastT) / 1000;
  lastT = ts;
  if(dt > 0.05) dt = 0.016; // cap

  update(dt);
  draw();
}
requestAnimationFrame(frame);

})();
</script>
</body>
</html>
