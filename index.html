<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Flip - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Flip - Tap to flip gravity up/down while dodging obstacles from both sides. Collect stars for bonus points. Obstacles speed up gradually.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Flip - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity up/down while dodging obstacles. Collect stars for bonus points. How far can you go?">
<meta property="og:url" content="https://balinti.github.io/gravity-flip/">
<meta property="og:image" content="https://balinti.github.io/gravity-flip/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#08081e;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none}
#wrap{position:relative;width:min(420px,100vw);height:min(750px,100vh);height:min(750px,100dvh);margin:0 auto;overflow:hidden;background:linear-gradient(180deg,#0a0a2e 0%,#151540 50%,#0a0a2e 100%)}
canvas{display:block;width:100%;height:100%}
#seo{position:absolute;bottom:2px;left:0;right:0;text-align:center;font-size:8px;color:rgba(255,255,255,0.12);pointer-events:none;padding:0 8px;line-height:1.3}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="seo">Gravity Flip – free hyper-casual HTML5 canvas game. Flip gravity between ceiling and floor lanes, pass through beat-synced gates, build combos. No download, play instantly in your browser.</div>
</div>
<script>
'use strict';
(()=>{

/* ════════════════ Canvas Setup ════════════════ */
const wrap=document.getElementById('wrap');
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let W,H,dpr;

function resize(){
  const r=wrap.getBoundingClientRect();
  W=r.width;H=r.height;
  dpr=Math.min(window.devicePixelRatio||1,3);
  canvas.width=W*dpr;
  canvas.height=H*dpr;
  canvas.style.width=W+'px';
  canvas.style.height=H+'px';
}
resize();
window.addEventListener('resize',resize);

/* ════════════════ Constants ════════════════ */
const LS_KEY='gfb_highscore';
const SAFE_BOTTOM=80;
const PLAYER_R=13;
const GATE_W=30;

/* Lane positions (ratio of playable area) */
function ceilY(){ return H*0.20; }
function floorY(){ return H*0.75; }
function playH(){ return floorY()-ceilY(); }
function gapH(){ return playH()*0.30; }
function perfectH(){ return playH()*0.10; }
function playerX(){ return W*0.22; }

/* ════════════════ State Variables ════════════════ */
let state='start'; // start | playing | gameover
let score,bestScore,combo,peakCombo,comboMul;
let playerLane,playerY,targetY,playerVY;
let gameTime,beatTimer,bpm,gateSpeed;
let gates,particles,riskRings,pendingRisk;
let shakeX,shakeY,shakeDur,shakeInt;
let slowMo,countdownTimer,countdownPhase;
let hue,flashAlpha,lastFlipTime;
let prevGateOpenLane; // track last gate's open lane for fairness
let lastBeatGateTime; // time of last gate spawn

bestScore=parseInt(localStorage.getItem(LS_KEY))||0;

/* Combo ladder */
function getMul(c){
  if(c<2)return 1;
  if(c<5)return 2;
  if(c<10)return 3;
  if(c<20)return 5;
  return 8;
}

/* ════════════════ Init / Reset ════════════════ */
function resetGame(){
  score=0;combo=0;peakCombo=0;comboMul=1;
  playerLane=1;playerY=floorY();targetY=floorY();playerVY=0;
  gameTime=0;beatTimer=0;bpm=100;gateSpeed=170;
  gates=[];particles=[];riskRings=[];pendingRisk=0;
  shakeX=0;shakeY=0;shakeDur=0;shakeInt=0;
  slowMo=0;countdownTimer=0;countdownPhase=0;
  hue=200;flashAlpha=0;lastFlipTime=0;
  prevGateOpenLane=-1;lastBeatGateTime=-10;
}
resetGame();

/* ════════════════ Input ════════════════ */
function handleInput(){
  if(state==='start'){
    state='playing';
    resetGame();
    countdownPhase=3;countdownTimer=0;
    return;
  }
  if(state==='gameover'){
    state='start';
    resetGame();
    return;
  }
  if(state==='playing'&&countdownPhase<=0){
    flipPlayer();
  }
}

canvas.addEventListener('pointerdown',e=>{e.preventDefault();handleInput();},{passive:false});
canvas.addEventListener('touchstart',e=>{e.preventDefault();},{passive:false});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();handleInput();}
});

function flipPlayer(){
  const now=performance.now();
  if(now-lastFlipTime<90)return;
  lastFlipTime=now;
  playerLane=playerLane===0?1:0;
  targetY=playerLane===0?ceilY():floorY();
  // flip burst
  for(let i=0;i<10;i++){
    spawnParticle(playerX(),playerY,hue,0.6,'flip');
  }
}

/* ════════════════ Particles ════════════════ */
function spawnParticle(x,y,h,life,type){
  const a=Math.random()*Math.PI*2;
  const spd=type==='crash'?Math.random()*250+100:
            type==='ring'?0:
            type==='perfect'?Math.random()*150+60:
            type==='risk'?Math.random()*100+40:
            Math.random()*90+25;
  particles.push({
    x,y,
    vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,
    life,maxLife:life,
    h,s:type==='perfect'?95:70,l:type==='perfect'?78:60,
    r:type==='crash'?Math.random()*5+2:type==='ring'?PLAYER_R:Math.random()*3+1.2,
    type,
    drag:type==='ring'?1:0.95,
    ringR:type==='ring'?PLAYER_R:0,
    ringMax:type==='ring'?Math.max(W,H)*0.35:0
  });
}

function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.life-=dt;
    if(p.life<=0){particles.splice(i,1);continue;}
    if(p.type==='ring'){
      p.ringR+=(p.ringMax-p.ringR)*dt*3.5;
    }else{
      p.vx*=p.drag;p.vy*=p.drag;
      p.x+=p.vx*dt;p.y+=p.vy*dt;
    }
  }
}

function drawParticles(){
  for(const p of particles){
    const a=Math.max(0,p.life/p.maxLife);
    if(p.type==='ring'){
      ctx.strokeStyle=`hsla(${p.h},${p.s}%,${p.l}%,${a*0.45})`;
      ctx.lineWidth=3*a;
      ctx.beginPath();ctx.arc(p.x,p.y,p.ringR,0,Math.PI*2);ctx.stroke();
    }else{
      ctx.globalAlpha=a;
      ctx.fillStyle=`hsl(${p.h},${p.s}%,${p.l}%)`;
      ctx.beginPath();ctx.arc(p.x,p.y,p.r*(0.4+a*0.6),0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=1;
    }
  }
}

/* ════════════════ Gate Spawning ════════════════ */
function spawnGate(){
  // Fairness: avoid same lane repeatedly (max 3 in a row, bias toward alternating)
  let openLane;
  if(prevGateOpenLane===-1){
    openLane=Math.random()<0.5?0:1;
  }else{
    // 65% chance to flip, 35% to repeat
    openLane=Math.random()<0.65?(1-prevGateOpenLane):prevGateOpenLane;
  }

  // Fairness: don't require flip within 0.18s
  const beatInt=60/bpm;
  if(beatInt<0.20&&openLane!==prevGateOpenLane){
    // If beats too fast and requiring a flip, skip
    if(gameTime-lastBeatGateTime<0.18){
      return;
    }
  }

  prevGateOpenLane=openLane;
  lastBeatGateTime=gameTime;

  gates.push({
    x:W+GATE_W,
    openLane,
    passed:false,
    perfectHit:false,
    age:0,
    w:GATE_W
  });
}

function maybeSpawnRisk(){
  if(gameTime<25||combo<2)return;
  if(Math.random()>0.25)return;
  const lane=Math.random()<0.5?0:1;
  riskRings.push({
    x:W+30,
    y:lane===0?ceilY():floorY(),
    lane,r:11,
    collected:false,
    value:3
  });
}

/* ════════════════ Crash ════════════════ */
function crash(){
  state='gameover';
  if(score>bestScore){
    bestScore=score;
    localStorage.setItem(LS_KEY,bestScore.toString());
  }
  shakeInt=14;shakeDur=0.55;
  slowMo=0.45;flashAlpha=0.55;
  for(let i=0;i<40;i++) spawnParticle(playerX(),playerY,0,1.2,'crash');
  spawnParticle(playerX(),playerY,0,0.9,'ring');
}

/* ════════════════ Update ════════════════ */
function update(dt){
  hue=(hue+dt*18)%360;

  // Shake
  if(shakeDur>0){
    shakeDur-=dt;
    const t=Math.max(0,shakeDur/0.55)*shakeInt;
    shakeX=(Math.random()-0.5)*t*2;
    shakeY=(Math.random()-0.5)*t*2;
  }else{shakeX=0;shakeY=0;}

  // Slow-mo decay
  if(slowMo>0) slowMo=Math.max(0,slowMo-dt*1.8);

  // Flash decay
  if(flashAlpha>0) flashAlpha=Math.max(0,flashAlpha-dt*3);

  if(state!=='playing')return;

  // Countdown
  if(countdownPhase>0){
    countdownTimer+=dt;
    if(countdownTimer>=0.65){
      countdownTimer=0;
      countdownPhase--;
    }
    return;
  }

  // Time multiplier for slow-mo
  const tm=slowMo>0?0.25:1;
  const adt=dt*tm;
  gameTime+=adt;

  // Difficulty ramp
  bpm=100+Math.min(score*0.6,70);
  gateSpeed=170+Math.min(score*1.8,180);

  // Add pattern complexity: after score 30, occasionally double-beat
  // (handled by beat timer allowing more frequent spawns)

  // Player spring physics
  const springK=28;
  const damping=9;
  const dy=targetY-playerY;
  playerVY+=(dy*springK-playerVY*damping)*adt;
  playerY+=playerVY*adt;

  // Trail particles
  if(Math.random()<0.25){
    particles.push({
      x:playerX()-PLAYER_R+Math.random()*4,
      y:playerY+(Math.random()-0.5)*6,
      vx:-25-Math.random()*20,vy:(Math.random()-0.5)*8,
      life:0.35,maxLife:0.35,h:hue,s:55,l:48,r:1.8,type:'trail',drag:0.94,
      ringR:0,ringMax:0
    });
  }

  // Beat scheduling
  const beatInt=60/bpm;
  beatTimer+=adt;
  if(beatTimer>=beatInt){
    beatTimer-=beatInt;
    spawnGate();
    if(Math.random()<0.2) maybeSpawnRisk();
  }

  // Update gates
  const px=playerX();
  const pr=PLAYER_R;

  for(let i=gates.length-1;i>=0;i--){
    const g=gates[i];
    g.x-=gateSpeed*adt;
    g.age+=adt;

    // Remove off-screen
    if(g.x<-GATE_W*2){gates.splice(i,1);continue;}

    const gLeft=g.x-g.w/2;
    const gRight=g.x+g.w/2;

    // Did gate just pass player?
    if(!g.passed&&gRight<px-pr+2){
      g.passed=true;
      score++;

      // Check perfect
      const openCenter=g.openLane===0?ceilY():floorY();
      const dist=Math.abs(playerY-openCenter);
      const perfH=perfectH()/2;

      if(dist<perfH){
        // PERFECT
        g.perfectHit=true;
        combo++;
        if(combo>peakCombo) peakCombo=combo;
        comboMul=getMul(combo);
        const bonus=2*comboMul;
        score+=bonus;
        // FX
        shakeInt=3;shakeDur=0.12;
        for(let j=0;j<14;j++) spawnParticle(px,playerY,55,0.7,'perfect');
        // Risk payout
        if(pendingRisk>0){
          score+=pendingRisk*comboMul;
          pendingRisk=0;
        }
      }else{
        // Passed but not perfect
        combo=0;comboMul=1;
        pendingRisk=0;
      }
    }

    // Collision: player overlaps gate strip
    if(!g.passed&&px+pr>gLeft&&px-pr<gRight){
      const inOpen=(playerLane===g.openLane);
      if(!inOpen){
        crash();return;
      }
    }
  }

  // Risk rings
  for(let i=riskRings.length-1;i>=0;i--){
    const rr=riskRings[i];
    rr.x-=gateSpeed*adt;
    if(rr.x<-40){riskRings.splice(i,1);continue;}
    if(!rr.collected){
      const dx=rr.x-px;
      const dy2=rr.y-playerY;
      const d=Math.sqrt(dx*dx+dy2*dy2);
      if(d<pr+rr.r){
        rr.collected=true;
        pendingRisk+=rr.value;
        for(let j=0;j<8;j++) spawnParticle(rr.x,rr.y,45,0.5,'risk');
      }
    }
  }

  updateParticles(adt);
}

/* ════════════════ Drawing ════════════════ */
function drawBg(){
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#0a0a2e');
  g.addColorStop(0.5,'#12123a');
  g.addColorStop(1,'#0a0a2e');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  // Lane lines
  ctx.strokeStyle='rgba(255,255,255,0.05)';
  ctx.lineWidth=1;
  ctx.setLineDash([6,10]);
  ctx.beginPath();
  ctx.moveTo(0,ceilY());ctx.lineTo(W,ceilY());
  ctx.moveTo(0,floorY());ctx.lineTo(W,floorY());
  ctx.stroke();
  ctx.setLineDash([]);

  // Mid line
  const mid=(ceilY()+floorY())/2;
  ctx.strokeStyle='rgba(255,255,255,0.025)';
  ctx.beginPath();ctx.moveTo(0,mid);ctx.lineTo(W,mid);ctx.stroke();

  // Moving grid dots for depth
  const dotSpacing=40;
  const offset=(gameTime*60)%dotSpacing;
  ctx.fillStyle='rgba(255,255,255,0.02)';
  for(let x=-offset;x<W+dotSpacing;x+=dotSpacing){
    for(let y=ceilY();y<floorY();y+=dotSpacing){
      ctx.fillRect(x,y,1.5,1.5);
    }
  }
}

function drawGates(){
  for(const g of gates){
    const alpha=Math.min(g.age*2.5,1);
    const gh=gapH();
    const pH=perfectH();
    const openC=g.openLane===0?ceilY():floorY();
    const closedC=g.openLane===0?floorY():ceilY();

    // Telegraph line (faint) when far away
    if(alpha<0.9){
      ctx.globalAlpha=alpha*0.15;
      ctx.strokeStyle=`hsl(${hue+40},60%,50%)`;
      ctx.lineWidth=1;
      ctx.beginPath();ctx.moveTo(g.x,ceilY()-20);ctx.lineTo(g.x,floorY()+20);ctx.stroke();
    }

    // Closed lane - RED slab
    ctx.globalAlpha=alpha*0.88;
    const slabH=gh*1.1;
    // Slab gradient
    const sg=ctx.createLinearGradient(g.x-g.w/2,0,g.x+g.w/2,0);
    sg.addColorStop(0,'hsla(355,70%,38%,0.9)');
    sg.addColorStop(0.5,'hsla(355,75%,45%,0.95)');
    sg.addColorStop(1,'hsla(355,70%,38%,0.9)');
    ctx.fillStyle=sg;
    ctx.fillRect(g.x-g.w/2,closedC-slabH/2,g.w,slabH);
    // Border
    ctx.strokeStyle=`hsla(0,80%,55%,${alpha*0.8})`;
    ctx.lineWidth=1.5;
    ctx.strokeRect(g.x-g.w/2,closedC-slabH/2,g.w,slabH);
    // Danger lines
    ctx.globalAlpha=alpha*0.3;
    ctx.strokeStyle='hsla(0,90%,70%,0.5)';
    ctx.lineWidth=1;
    for(let dy=-slabH/2+6;dy<slabH/2;dy+=8){
      ctx.beginPath();
      ctx.moveTo(g.x-g.w/2+2,closedC+dy);
      ctx.lineTo(g.x-g.w/2+g.w/2,closedC+dy-6);
      ctx.stroke();
    }

    // Open lane - GREEN frame
    ctx.globalAlpha=alpha*0.75;
    ctx.strokeStyle=`hsla(130,75%,52%,${alpha})`;
    ctx.lineWidth=2;
    ctx.strokeRect(g.x-g.w/2,openC-gh/2,g.w,gh);
    // Fill subtle
    ctx.fillStyle=`hsla(130,60%,45%,${alpha*0.08})`;
    ctx.fillRect(g.x-g.w/2,openC-gh/2,g.w,gh);

    // Perfect window - CYAN band
    ctx.fillStyle=`hsla(185,95%,65%,${alpha*0.3})`;
    ctx.fillRect(g.x-g.w/2,openC-pH/2,g.w,pH);
    ctx.strokeStyle=`hsla(185,95%,70%,${alpha*0.55})`;
    ctx.lineWidth=1;
    ctx.strokeRect(g.x-g.w/2,openC-pH/2,g.w,pH);

    // Perfect label
    if(alpha>0.7&&!g.passed){
      ctx.globalAlpha=alpha*0.3;
      ctx.fillStyle='hsla(185,95%,80%,0.6)';
      ctx.font='bold 7px "Segoe UI",system-ui,sans-serif';
      ctx.textAlign='center';
      ctx.fillText('PERFECT',g.x,openC+2.5);
    }

    ctx.globalAlpha=1;
  }
}

function drawRiskRings(){
  for(const rr of riskRings){
    if(rr.collected)continue;
    const pulse=0.75+Math.sin(gameTime*9)*0.25;
    // Outer ring
    ctx.strokeStyle='hsla(48,95%,62%,0.75)';
    ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*pulse,0,Math.PI*2);ctx.stroke();
    // Inner glow
    ctx.fillStyle='hsla(48,90%,60%,0.2)';
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*pulse,0,Math.PI*2);ctx.fill();
    // Diamond
    ctx.fillStyle='hsla(48,95%,72%,0.9)';
    ctx.save();ctx.translate(rr.x,rr.y);ctx.rotate(Math.PI/4);
    ctx.fillRect(-3.5,-3.5,7,7);
    ctx.restore();
  }
}

function drawPlayer(){
  const px=playerX();
  const py=playerY;
  const r=PLAYER_R;

  // Outer glow
  const glow=ctx.createRadialGradient(px,py,r*0.2,px,py,r*3);
  glow.addColorStop(0,`hsla(${hue},85%,62%,0.35)`);
  glow.addColorStop(1,`hsla(${hue},85%,62%,0)`);
  ctx.fillStyle=glow;
  ctx.beginPath();ctx.arc(px,py,r*3,0,Math.PI*2);ctx.fill();

  // Body
  ctx.fillStyle=`hsl(${hue},78%,58%)`;
  ctx.beginPath();ctx.arc(px,py,r,0,Math.PI*2);ctx.fill();

  // Inner ring
  ctx.strokeStyle=`hsla(${hue},90%,75%,0.4)`;
  ctx.lineWidth=1.5;
  ctx.beginPath();ctx.arc(px,py,r*0.65,0,Math.PI*2);ctx.stroke();

  // Highlight
  ctx.fillStyle=`hsla(${hue},95%,85%,0.45)`;
  ctx.beginPath();ctx.arc(px-r*0.22,py-r*0.22,r*0.38,0,Math.PI*2);ctx.fill();

  // Magnetic field lines
  ctx.strokeStyle=`hsla(${hue},70%,70%,0.2)`;
  ctx.lineWidth=1;
  const dir=playerLane===0?1:-1;
  for(let i=0;i<3;i++){
    const off=(gameTime*90+i*16)%45;
    ctx.beginPath();
    ctx.arc(px,py,r+off*0.5,
      dir>0?-0.5:Math.PI-0.5,
      dir>0?0.5:Math.PI+0.5);
    ctx.stroke();
  }

  // Lane indicator arrow
  ctx.fillStyle=`hsla(${hue},80%,70%,0.35)`;
  const arrowDir=playerLane===0?-1:1;
  ctx.beginPath();
  ctx.moveTo(px-5,py+arrowDir*(r+4));
  ctx.lineTo(px+5,py+arrowDir*(r+4));
  ctx.lineTo(px,py+arrowDir*(r+10));
  ctx.closePath();ctx.fill();
}

function drawHUD(){
  // Score top-left
  ctx.fillStyle='rgba(255,255,255,0.92)';
  ctx.font='bold 26px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign='left';ctx.textBaseline='top';
  ctx.fillText(score,16,14);

  // Label
  ctx.font='10px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.35)';
  ctx.fillText('SCORE',16,42);

  // Combo - top right
  if(combo>=2){
    const sc2=1+Math.sin(gameTime*7)*0.1;
    ctx.save();
    ctx.translate(W-16,18);
    ctx.scale(sc2,sc2);
    ctx.textAlign='right';ctx.textBaseline='top';
    ctx.font='bold 30px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle=`hsl(${(hue+60)%360},92%,65%)`;
    ctx.fillText('x'+comboMul,0,0);
    ctx.restore();

    ctx.font='11px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign='right';ctx.textBaseline='top';
    ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.fillText(combo+' COMBO',W-16,50);
  }

  // Pending risk
  if(pendingRisk>0){
    const pa=0.7+Math.sin(gameTime*5)*0.3;
    ctx.font='bold 13px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign='center';ctx.textBaseline='top';
    ctx.fillStyle=`hsla(48,92%,62%,${pa})`;
    ctx.fillText('RISK +'+pendingRisk+(comboMul>1?' (x'+comboMul+')':''),W/2,14);
  }

  // BPM indicator (subtle)
  ctx.font='9px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign='left';ctx.textBaseline='top';
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillText(Math.round(bpm)+' BPM',16,56);
}

function drawStartScreen(){
  ctx.fillStyle='rgba(10,10,40,0.72)';
  ctx.fillRect(0,0,W,H);

  ctx.textAlign='center';ctx.textBaseline='middle';

  // Title
  const ty=H*0.28;
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.4)';
  ctx.font='bold 44px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('GRAVITY',W/2+2,ty-26+2);
  ctx.fillText('FLIP',W/2+2,ty+26+2);
  // Main
  ctx.fillStyle=`hsl(${hue},82%,72%)`;
  ctx.fillText('GRAVITY',W/2,ty-26);
  ctx.fillStyle=`hsl(${(hue+40)%360},82%,72%)`;
  ctx.fillText('FLIP',W/2,ty+26);

  // Subtitle
  ctx.font='13px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fillText('Beat Gates  ·  Combo Runner',W/2,ty+62);

  // Instructions
  ctx.font='12px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.35)';
  const ins=[
    'Tap or press Space to flip between lanes',
    'Pass through the GREEN open side of gates',
    'Hit the CYAN perfect zone for combo multipliers',
    'RED slabs = instant crash!'
  ];
  ins.forEach((t,i)=>{
    ctx.fillText(t,W/2,H*0.48+i*22);
  });

  // Best
  if(bestScore>0){
    ctx.font='bold 15px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle='hsla(48,90%,65%,0.8)';
    ctx.fillText('BEST: '+bestScore,W/2,H*0.66);
  }

  // Tap to start
  const pulse=0.45+Math.sin(performance.now()*0.004)*0.55;
  ctx.globalAlpha=pulse;
  ctx.font='bold 18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='#fff';
  ctx.fillText('TAP TO START',W/2,H*0.76);
  ctx.globalAlpha=1;

  // Controls
  ctx.font='10px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.2)';
  ctx.fillText('Tap · Space · Enter',W/2,H*0.82);
}

function drawCountdown(){
  if(countdownPhase<=0)return;
  const prog=countdownTimer/0.65;
  const sc2=1.6-prog*0.6;
  const al=1-prog*0.6;

  ctx.save();
  ctx.globalAlpha=al;
  ctx.textAlign='center';ctx.textBaseline='middle';

  // Glow circle
  ctx.fillStyle=`hsla(${hue},80%,60%,${al*0.15})`;
  ctx.beginPath();ctx.arc(W/2,H/2,60*sc2,0,Math.PI*2);ctx.fill();

  // Number
  ctx.font=`bold ${65*sc2}px "Segoe UI",system-ui,sans-serif`;
  ctx.fillStyle=`hsl(${hue},82%,72%)`;
  ctx.fillText(countdownPhase.toString(),W/2,H/2);
  ctx.restore();
}

function drawGameOver(){
  ctx.fillStyle='rgba(8,8,30,0.78)';
  ctx.fillRect(0,0,W,H);

  ctx.textAlign='center';ctx.textBaseline='middle';

  // Game Over
  ctx.font='bold 38px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='hsla(0,70%,62%,0.92)';
  ctx.fillText('GAME OVER',W/2,H*0.22);

  // Score
  ctx.font='11px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fillText('SCORE',W/2,H*0.31);

  ctx.font='bold 56px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='#fff';
  ctx.fillText(score.toString(),W/2,H*0.39);

  // Best
  const isNew=score>=bestScore&&score>0;
  ctx.font='bold 22px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=isNew?'hsl(48,92%,65%)':'rgba(255,255,255,0.65)';
  ctx.fillText('BEST: '+bestScore,W/2,H*0.50);
  if(isNew){
    ctx.font='bold 12px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle='hsl(48,92%,65%)';
    ctx.fillText('NEW RECORD!',W/2,H*0.545);
  }

  // Peak combo
  if(peakCombo>=2){
    ctx.font='15px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle='rgba(255,255,255,0.55)';
    ctx.fillText('PEAK COMBO: '+peakCombo+' (x'+getMul(peakCombo)+')',W/2,H*0.60);
  }

  // Retry
  const pulse=0.4+Math.sin(performance.now()*0.004)*0.6;
  ctx.globalAlpha=pulse;
  ctx.font='bold 18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle='#fff';
  ctx.fillText('TAP TO RETRY',W/2,H*0.72);
  ctx.globalAlpha=1;
}

/* ════════════════ Main Loop ════════════════ */
let lastTime=0;

function frame(ts){
  requestAnimationFrame(frame);
  if(!lastTime) lastTime=ts;
  let dt=(ts-lastTime)/1000;
  lastTime=ts;
  dt=Math.min(dt,0.033);

  update(dt);

  // Draw
  ctx.setTransform(dpr,0,0,dpr,0,0);
  drawBg();

  // Shake translate
  const shaking=shakeDur>0;
  if(shaking){
    ctx.save();ctx.translate(shakeX,shakeY);
  }

  if(state==='playing'){
    drawGates();
    drawRiskRings();
    drawPlayer();
    drawParticles();
    drawHUD();
    if(countdownPhase>0) drawCountdown();
  }

  if(shaking) ctx.restore();

  // Flash overlay
  if(flashAlpha>0){
    ctx.fillStyle=`rgba(255,80,80,${flashAlpha})`;
    ctx.fillRect(0,0,W,H);
  }

  if(state==='start'){
    drawParticles();
    drawStartScreen();
  }
  if(state==='gameover'){
    drawParticles();
    drawGameOver();
  }
}

requestAnimationFrame(frame);

})();
</script>
</body>
</html>
